<HTML>
<HEAD>
<TITLE>OpenTNL - TNL: TNL::NetObject Class Reference</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<link href="doco.css" rel="stylesheet" type="text/css">
</HEAD>
<BODY BGCOLOR=#FFFFFF LEFTMARGIN=0 TOPMARGIN=0 MARGINWIDTH=0 MARGINHEIGHT=0>
<TABLE WIDTH=100% height="100%" BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR height="47">
		<TD width="169" height="46"><a href="http://www.opentnl.org/"><IMG SRC="images/layout_tnllogo.gif" WIDTH=169 HEIGHT=47 ALT="" border=0></a></TD>
		<TD width="100%" height="46" BGCOLOR=#322900 valign=top><IMG SRC="images/layout_topbar.gif" HEIGHT=47 ALT=""></TD>
	</TR>
	<TR>
		<TD width="169" bgcolor="#1A1B4D" valign=top nowrap>
			<table WIDTH=169 BORDER=0 CELLPADDING=0 CELLSPACING=0 bgcolor="#1A1B4D">
			<tr WIDTH=169 HEIGHT=20>
				<td WIDTH=169 HEIGHT=20 valign=top>
				<IMG SRC="images/layout_left_tnl.gif" WIDTH=169 HEIGHT=20 ALT="">
				</td>
			</tr>
			<tr>
				<td>
				<a href="http://www.opentnl.org/index.php"><IMG SRC="images/layout_left_news.gif" ALT="News" WIDTH=169 HEIGHT=30 border="0"></a>
				<a href="http://sourceforge.net/projects/opentnl"><img src="images/layout_left_sf.gif" width="169" height="30" border="0" alt="SF.net Project"></a>
				<a href="http://www.opentnl.org/faq.php"><IMG SRC="images/layout_left_faq.gif" ALT="Frequently Asked Questions" WIDTH=169 HEIGHT=30 border="0"></a>
				<a href="http://www.opentnl.org/docs.php"><IMG SRC="images/layout_left_documentation.gif" ALT="Documentation" WIDTH=169 HEIGHT=30 border="0"></a>
				<a href="http://www.opentnl.org/download.php"><IMG SRC="images/layout_left_downloads.gif" ALT="Downloads" WIDTH=169 HEIGHT=30 border="0"></a>
				<a href="http://sourceforge.net/mail/?group_id=106342"><IMG SRC="images/layout_left_mailing.gif" ALT="Mailing Lists" WIDTH=169 HEIGHT=30 border="0"></a>
				<a href="http://www.opentnl.org/contribute.php"><IMG SRC="images/layout_left_contributors.gif" ALT="How to Contribute" WIDTH=169 HEIGHT=30 border="0"></a>

				<p align="center">
				<a href="http://sourceforge.net">
				<img src="http://sourceforge.net/sflogo.php?group_id=opentnl&amp;type=2" width="125" height="37" border="0" alt="SourceForge.net Logo" />
				</a>
				<br>
				<br>
				<a href="http://www.garagegames.com/">
				<img src="images/gglogo.png" height=100 width=100 border=0 ALT="Changing the way games are made and played.">
				</a>
				</p>

				</td>
			</tr>
			</table>
		</TD>
		<TD width=100% align="left" valign="top">
<div class="header">
	<div class="nav">TNL 1.5.0 - 29 May 2007</div>
	<div class="index">
	<a href="index.html">Main Page</a>
	<a href="modules.html">Modules</a>
	<a href="namespaces.html">Namespaces</a>
	<a href="hierarchy.html">C++ Classes</a>
	<a href="annotated.html">Compound List</a>
	<a href="files.html">File List</a>
	<a href="functions.html">Index</a>
	</div>
</div>
      <div class="article">
	<div class="title">
		TNL: TNL::NetObject Class Reference
	</div>

	<div class="body">
<!-- Generated by Doxygen 1.5.2 -->
<div class="nav">
<a class="el" href="namespaceTNL.html">TNL</a>::<a class="el" href="classTNL_1_1NetObject.html">NetObject</a></div>
<h1>TNL::NetObject Class Reference</h1><!-- doxytag: class="TNL::NetObject" --><!-- doxytag: inherits="TNL::Object" --><code>#include &lt;tnlNetObject.h&gt;</code>
<p>
<p>Inheritance diagram for TNL::NetObject:
<p><center><img src="classTNL_1_1NetObject.png" usemap="#TNL::NetObject_map" border="0" alt=""></center>
<map name="TNL::NetObject_map">
<area href="classTNL_1_1Object.html" alt="TNL::Object" shape="rect" coords="167,0,324,24">
<area href="classTNLTest_1_1Building.html" alt="TNLTest::Building" shape="rect" coords="0,112,157,136">
<area href="classTNLTest_1_1Player.html" alt="TNLTest::Player" shape="rect" coords="167,112,324,136">
<area href="classZap_1_1GameObject.html" alt="Zap::GameObject" shape="rect" coords="334,112,491,136">
<area href="classZap_1_1Barrier.html" alt="Zap::Barrier" shape="rect" coords="501,168,658,192">
<area href="classZap_1_1EngineeredObject.html" alt="Zap::EngineeredObject" shape="rect" coords="501,224,658,248">
<area href="classZap_1_1ForceField.html" alt="Zap::ForceField" shape="rect" coords="501,280,658,304">
<area href="classZap_1_1GameType.html" alt="Zap::GameType" shape="rect" coords="501,336,658,360">
<area href="classZap_1_1GoalZone.html" alt="Zap::GoalZone" shape="rect" coords="501,392,658,416">
<area href="classZap_1_1HuntersNexusObject.html" alt="Zap::HuntersNexusObject" shape="rect" coords="501,448,658,472">
<area href="classZap_1_1MoveObject.html" alt="Zap::MoveObject" shape="rect" coords="501,504,658,528">
<area href="classZap_1_1Projectile.html" alt="Zap::Projectile" shape="rect" coords="501,560,658,584">
<area href="classZap_1_1Teleporter.html" alt="Zap::Teleporter" shape="rect" coords="501,616,658,640">
</map>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Superclass for ghostable networked objects. 
<p>
<h2><a class="anchor" name="NetObject_intro">
Introduction To NetObject And Ghosting</a></h2>
One of the most powerful aspects of the Torque Network Library is its support for ghosting and prioritized, most-recent-state network updates. The way this works is a bit complex, but it is immensely efficient. Let's run through the steps that the server goes through for each client in this part of TNL's architecture:<ul>
<li>First, the server determines what objects are in-scope for the client. This is done by calling <a class="el" href="classTNL_1_1NetObject.html#81e9010708e91f3aa17fbd562370d49e" title="For a scope object, determine what is in scope.">performScopeQuery()</a> on the object which is considered the "scope" object. This could be a simulation avatar of the character, a flyby camera, a vehicle the user is controlling, or something else.</li><li>Second, it instructs the client to create "ghost" instances of those objects to represent the source objects on the server. Finally, it sends updates to the ghosts of those objects whose state has been updated on the server, prioritizing the updates based on how relevant the object is to that particular client.</li></ul>
<p>
There several significant advantages to using this networking system:<ul>
<li>Efficient network usage, since we only send data that has changed. In addition, since we only care about most-recent data, if a packet is dropped, we don't waste effort trying to deliver stale data.</li><li>Cheating protection; since <a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a> doesn't deliver information about game objects which aren't "in scope", the ability for clients to learn about objects outside their immediate perceptions can be curtailed by an agressive scoping function.</li></ul>
<h2><a class="anchor" name="NetObject_Implementation">
An Example Implementation</a></h2>
The basis of the ghost implementation in <a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a> is <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a>. Each <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> maintains an <b>updateMask</b>, a 32 bit word representing up to 32 independent states for the object. When a NetObject's state changes it calls the setMaskBits method to notify the network layer that the state has changed and needs to be updated on all clients that have that <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> in scope.<p>
Using a <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> is very simple; let's go through a simple example implementation:<p>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>SimpleNetObject : <span class="keyword">public</span> <a class="code" href="classTNL_1_1NetObject.html#6e60ac3903380981362014078db112c3">NetObject</a>
 {
 <span class="keyword">public</span>:
   <span class="keyword">typedef</span> <a class="code" href="classTNL_1_1NetObject.html#6e60ac3903380981362014078db112c3">NetObject</a> <a class="code" href="classTNL_1_1NetObject.html#48b0d15649551fe170fee485b0d126bb">Parent</a>;
   <a class="code" href="tnlNetBase_8h.html#18f4e48400d4e57cf76fb9bdd356c3fd" title="The TNL_DECLARE_CLASS macro should be called within the declaration of any network...">TNL_DECLARE_CLASS</a>(SimpleNetObject);
</pre></div><p>
Above is the standard boilerplate code for a <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> subclass.<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">char</span> message1[256];
    <span class="keywordtype">char</span> message2[256];
    <span class="keyword">enum</span> States {
       Message1Mask = <a class="code" href="tnlTypes_8h.html#d27cc17b25bb93134368d5eb21126eae">BIT</a>(0),
       Message2Mask = <a class="code" href="tnlTypes_8h.html#d27cc17b25bb93134368d5eb21126eae">BIT</a>(1),
    };
</pre></div><p>
The example class has two object "states" that each instance keeps track of, message1 and message2. A real game object might have states for health, velocity and position, or some other set of fields. Each class has 32 bits to work with, so it's possible to be very specific when defining states. In general, individual state bits should be assigned only to things that are updated independently - so if you update the position field and the velocity at the same time always, you could use a single bit to represent that state change.<p>
<div class="fragment"><pre class="fragment">    SimpleNetObject()
    {
       <span class="comment">// in order for an object to be considered by the network system,</span>
       <span class="comment">// the Ghostable net flag must be set.</span>
       <span class="comment">// the ScopeAlways flag indicates that the object is always scoped</span>
       <span class="comment">// on all active connections.</span>
       <a class="code" href="classTNL_1_1NetObject.html#7cab04892c210057e9ab764e50c21410" title="Flags field describing this object, from NetFlag.">mNetFlags</a>.set(ScopeAlways | <a class="code" href="classTNL_1_1NetObject.html#d09d727c2d3fbf870a1ca33f4925d89fdbb46327d5b781ebcd956ca3a8bd05b2" title="Set if this object can ghost at all.">Ghostable</a>);
       strcpy(message1, <span class="stringliteral">"Hello World 1!"</span>);
       strcpy(message2, <span class="stringliteral">"Hello World 2!"</span>);
    }
</pre></div><p>
Here is the constructor. The code initializes the net flags, indicating that the SimpleNetObject should always be scoped, and that it can be ghosted to remote hosts<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1" title="Compiler independent unsigned 32-bit integer.">U32</a> <a class="code" href="classTNL_1_1NetObject.html#5ae1ab5301e16b7659b0839b120150a0" title="Write the object's state to a packet.">packUpdate</a>(<a class="code" href="classTNL_1_1NetObject.html#89952c4864e81b347f33b783bf8b57d9">GhostConnection</a> *, <a class="code" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1" title="Compiler independent unsigned 32-bit integer.">U32</a> mask, BitStream *stream)
    {
       <span class="comment">// check which states need to be updated, and write updates</span>
       <span class="keywordflow">if</span>(stream-&gt;writeFlag(mask &amp; Message1Mask))
          stream-&gt;writeString(message1);
       <span class="keywordflow">if</span>(stream-&gt;writeFlag(mask &amp; Message2Mask))
          stream-&gt;writeString(message2);

       <span class="comment">// the return value from packUpdate can set which states still</span>
       <span class="comment">// need to be updated for this object.</span>
       <span class="keywordflow">return</span> 0;
    }
</pre></div><p>
Here's half of the meat of the networking code, the <a class="el" href="classTNL_1_1NetObject.html#5ae1ab5301e16b7659b0839b120150a0" title="Write the object's state to a packet.">packUpdate()</a> function. (The other half, <a class="el" href="classTNL_1_1NetObject.html#f3eda283fef93bad7b3b7f5d8cce28e8" title="Unpack data written by packUpdate().">unpackUpdate()</a>, is shown below.) The comments in the code pretty much explain everything, however, notice that the code follows a pattern of if(writeFlag(mask &amp; StateMask)) { ... write data ... }. The <a class="el" href="classTNL_1_1NetObject.html#5ae1ab5301e16b7659b0839b120150a0" title="Write the object's state to a packet.">packUpdate()</a>/unpackUpdate() functions are responsible for reading and writing the update flags to the <a class="el" href="classTNL_1_1BitStream.html" title="BitStream provides a bit-level stream interface to a data buffer.">BitStream</a>. This means the <a class="el" href="classTNL_1_1GhostConnection.html" title="GhostConnection is a subclass of EventConnection that manages the transmission (ghosting)...">GhostConnection</a> doesn't have to send the 32 bit updateMask with every packet.<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> <a class="code" href="classTNL_1_1NetObject.html#f3eda283fef93bad7b3b7f5d8cce28e8" title="Unpack data written by packUpdate().">unpackUpdate</a>(<a class="code" href="classTNL_1_1NetObject.html#89952c4864e81b347f33b783bf8b57d9">GhostConnection</a> *, BitStream *stream)
    {
       <span class="comment">// the unpackUpdate function must be symmetrical to packUpdate</span>
       <span class="keywordflow">if</span>(stream-&gt;readFlag())
       {
          stream-&gt;readString(message1);
          <a class="code" href="namespaceTNL.html#753dfaae40cfc4e7b73cd24de7b9ada5" title="Global interface to the TNL logging system.">logprintf</a>(<span class="stringliteral">"Got message1: %s"</span>, message1);
       }
       <span class="keywordflow">if</span>(stream-&gt;readFlag())
       {
          stream-&gt;readString(message2);
          <a class="code" href="namespaceTNL.html#753dfaae40cfc4e7b73cd24de7b9ada5" title="Global interface to the TNL logging system.">logprintf</a>(<span class="stringliteral">"Got message2: %s"</span>, message2);
       }
    }
</pre></div><p>
The other half of the networking code in any <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a>, <a class="el" href="classTNL_1_1NetObject.html#f3eda283fef93bad7b3b7f5d8cce28e8" title="Unpack data written by packUpdate().">unpackUpdate()</a>. In SimpleNetObject, all the code does is print the new messages to the log; however, in a more advanced object, the code might trigger animations, update complex object properties, or even spawn new objects, based on what packet data is unpacked.<p>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> setMessage1(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg)
    {
       <a class="code" href="classTNL_1_1NetObject.html#1273616c155111f51bc3d1f8267e5293" title="Notify the network system that one or more of this object's states have been changed...">setMaskBits</a>(Message1Mask);
       strcpy(message1, msg);
    }
    <span class="keywordtype">void</span> setMessage2(<span class="keyword">const</span> <span class="keywordtype">char</span> *msg)
    {
       <a class="code" href="classTNL_1_1NetObject.html#1273616c155111f51bc3d1f8267e5293" title="Notify the network system that one or more of this object's states have been changed...">setMaskBits</a>(Message2Mask);
       strcpy(message2, msg);
    }
</pre></div><p>
Here are the accessors for the two properties. It is good to encapsulate state variables, so that you don't have to remember to make a call to setMaskBits every time you change anything; the accessors can do it for you. In a more complex object, you might need to set multiple mask bits when you change something; this can be done using the | operator, for instance, setMaskBits( Message1Mask | Message2Mask ); if you changed both messages.<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="tnlNetObject_8h.html#7a562b4f92a08ca85fea22f528ff1b5a" title="The TNL_IMPLEMENT_NETOBJECT macro should be used for all subclasses of NetObject...">TNL_IMPLEMENT_NETOBJECT</a>(SimpleNetObject);
</pre></div><p>
Finally, we use the <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> implementation macro, <a class="el" href="tnlNetObject_8h.html#7a562b4f92a08ca85fea22f528ff1b5a" title="The TNL_IMPLEMENT_NETOBJECT macro should be used for all subclasses of NetObject...">TNL_IMPLEMENT_NETOBJECT()</a>, to implement our <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a>. It is important that we use this, as it makes <a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a> perform certain initialization tasks that allow us to send the object over the network. <a class="el" href="tnlNetBase_8h.html#d6a26aa97bdc16a78d9ef9415d9439cd" title="The TNL_IMPLEMENT_CLASS macro should be used for classes that will be auto-constructed...">TNL_IMPLEMENT_CLASS()</a> doesn't perform these tasks, see the documentation on <a class="el" href="classTNL_1_1NetClassRep.html" title="NetClassRep class instances represent each declared NetClass and are used to construct...">NetClassRep</a> for more details. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#6e60ac3903380981362014078db112c3">NetObject</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#a8df4763623a665f9d2c0d89f70d35e6">~NetObject</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#109bbc7cec4d57c9f0c1830c773fe600">onGhostAdd</a> (<a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *theConnection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">onGhostAdd is called on the client side of a connection after the constructor and after the first call to unpackUpdate (the initial call).  <a href="#109bbc7cec4d57c9f0c1830c773fe600"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#d7d2b55015ce527a88eea1786899366a">onGhostRemove</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">onGhostRemove is called on the client side before the destructor when ghost has gone out of scope and is about to be deleted from the client.  <a href="#d7d2b55015ce527a88eea1786899366a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#050a38bbae03ce5b0c88e2c4759de1fc">onGhostAvailable</a> (<a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *theConnection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">onGhostAvailable is called on the server side after the server knows that the ghost is available and addressable via the getGhostIndex().  <a href="#050a38bbae03ce5b0c88e2c4759de1fc"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#1273616c155111f51bc3d1f8267e5293">setMaskBits</a> (<a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> orMask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify the network system that one or more of this object's states have been changed.  <a href="#1273616c155111f51bc3d1f8267e5293"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#a17898f6a5e9dbc8460622bdb483765e">clearMaskBits</a> (<a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> orMask)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Notify the network system that one or more of its states does not need to be updated.  <a href="#a17898f6a5e9dbc8460622bdb483765e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#3b5aaf4dae85007ace1afcab0da96448">getUpdatePriority</a> (<a class="el" href="classTNL_1_1NetObject.html">NetObject</a> *scopeObject, <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> updateMask, <a class="el" href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38">S32</a> updateSkips)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Called to determine the relative update priority of an object.  <a href="#3b5aaf4dae85007ace1afcab0da96448"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#5ae1ab5301e16b7659b0839b120150a0">packUpdate</a> (<a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *connection, <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> updateMask, <a class="el" href="classTNL_1_1BitStream.html">BitStream</a> *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the object's state to a packet.  <a href="#5ae1ab5301e16b7659b0839b120150a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#f3eda283fef93bad7b3b7f5d8cce28e8">unpackUpdate</a> (<a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *connection, <a class="el" href="classTNL_1_1BitStream.html">BitStream</a> *stream)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unpack data written by <a class="el" href="classTNL_1_1NetObject.html#5ae1ab5301e16b7659b0839b120150a0" title="Write the object's state to a packet.">packUpdate()</a>.  <a href="#f3eda283fef93bad7b3b7f5d8cce28e8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#81e9010708e91f3aa17fbd562370d49e">performScopeQuery</a> (<a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *connection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For a scope object, determine what is in scope.  <a href="#81e9010708e91f3aa17fbd562370d49e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#7233fda2cc4312c436f8e97b1bed75ef">getNetIndex</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">getNetIndex returns the index tag used to identify the server copy of a client object.  <a href="#7233fda2cc4312c436f8e97b1bed75ef"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#0395334cc77ffd098be735aaa59b6518">isGhost</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isGhost returns true if this object is a ghost of a server object.  <a href="#0395334cc77ffd098be735aaa59b6518"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#47e9d4503e8ba162697ff4be86d4f241">isScopeLocal</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isScopeLocal returns true if this object is scoped always to the local client.  <a href="#47e9d4503e8ba162697ff4be86d4f241"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#a0309814f89bb59720380752515fd251">isGhostable</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">isGhostable returns true if this object can be ghosted to any clients.  <a href="#a0309814f89bb59720380752515fd251"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#d7800c4ef8bbff37231c83fbf1751be9">getHashId</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a hash for this object.  <a href="#d7800c4ef8bbff37231c83fbf1751be9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#e548c585cc77350525a991687c1dd794">postRPCEvent</a> (<a class="el" href="classTNL_1_1NetObjectRPCEvent.html">NetObjectRPCEvent</a> *theEvent)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Internal method called by <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> RPC events when they are packed.  <a href="#e548c585cc77350525a991687c1dd794"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#4d26a18a7cb7cbb0f0235a88567806a0">collapseDirtyList</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">collapseDirtyList pushes all the mDirtyMaskBits down into the GhostInfo's for each object, and clears out the dirty list.  <a href="#4d26a18a7cb7cbb0f0235a88567806a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#ae6199a2b3b481cc6b62ada4db9614be">getRPCSourceConnection</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the connection from which the current RPC method originated, or NULL if not currently within the processing of an RPC method call.  <a href="#ae6199a2b3b481cc6b62ada4db9614be"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#f8e6ebb19349f27763a62e13b8785f30">setRPCDestConnection</a> (<a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *destConnection)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the connection to which all <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> RPCs will be destined.  <a href="#f8e6ebb19349f27763a62e13b8785f30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#a1d10249d8ead78b30a30835ad4cc900">getRPCDestConnection</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the connection that serves as the destination of <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> RPC method calls.  <a href="#a1d10249d8ead78b30a30835ad4cc900"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#d09d727c2d3fbf870a1ca33f4925d89f">NetFlag</a> { <br>
&nbsp;&nbsp;<a class="el" href="classTNL_1_1NetObject.html#d09d727c2d3fbf870a1ca33f4925d89fa2161af5b6aebc78c12e79be56406445">IsGhost</a> =  BIT(1), 
<br>
&nbsp;&nbsp;<a class="el" href="classTNL_1_1NetObject.html#d09d727c2d3fbf870a1ca33f4925d89f470e75829d247485a3d3010c6551ff29">ScopeLocal</a> =  BIT(2), 
<br>
&nbsp;&nbsp;<a class="el" href="classTNL_1_1NetObject.html#d09d727c2d3fbf870a1ca33f4925d89fdbb46327d5b781ebcd956ca3a8bd05b2">Ghostable</a> =  BIT(3), 
<br>
&nbsp;&nbsp;<a class="el" href="classTNL_1_1NetObject.html#d09d727c2d3fbf870a1ca33f4925d89fb50d254c287de4f9243c68bf6a58846f">MaxNetFlagBit</a> =  15
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#049d4f6402a3792f88d3712dc7c7e249">isInitialUpdate</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if this pack/unpackUpdate is the initial one for the object.  <a href="#049d4f6402a3792f88d3712dc7c7e249"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTNL_1_1BitSet32.html">BitSet32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#7cab04892c210057e9ab764e50c21410">mNetFlags</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flags field describing this object, from NetFlag.  <a href="#7cab04892c210057e9ab764e50c21410"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#b091359493559597b7da1b568e4ca201">mRPCSourceConnection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RPC method source connection.  <a href="#b091359493559597b7da1b568e4ca201"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#2c90cd93b0d1ac79552a0421ac1914ef">mRPCDestConnection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> RPC method destination connection.  <a href="#2c90cd93b0d1ac79552a0421ac1914ef"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Private Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classTNL_1_1Object.html">Object</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#48b0d15649551fe170fee485b0d126bb">Parent</a></td></tr>

<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTNL_1_1NetObject.html">NetObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#5e51ba1758c711016ac4d1a578462316">mPrevDirtyList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTNL_1_1NetObject.html">NetObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#bde3b16fb4b2d8ae1cf5dbac284a1276">mNextDirtyList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#05043543d90c36fe613bbc51141060ee">mDirtyMaskBits</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#56df1ec7fea03e881cd501191117b1e5">mNetIndex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The index of this ghost on the other side of the connection.  <a href="#56df1ec7fea03e881cd501191117b1e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="structTNL_1_1GhostInfo.html">GhostInfo</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#6564e3aa5fc664c99781334ef1bc0405">mFirstObjectRef</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Head of the linked list of GhostInfos for this object.  <a href="#6564e3aa5fc664c99781334ef1bc0405"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTNL_1_1SafePtr.html">SafePtr</a>&lt; <a class="el" href="classTNL_1_1NetObject.html">NetObject</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#ad0b9a995363d64c3e6c1214c95a99b9">mServerObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct pointer to the parent object on the server if it is a local connection.  <a href="#ad0b9a995363d64c3e6c1214c95a99b9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#340fd14b3ab1badf4ef77c8a647af3a5">mOwningConnection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The connection that owns this ghost, if it's a ghost.  <a href="#340fd14b3ab1badf4ef77c8a647af3a5"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static <a class="el" href="classTNL_1_1NetObject.html">NetObject</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#187c2b97fe60531ba5586286f5a2aed2">mDirtyList</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#aa23bf48466753be3b647021960617ff">mIsInitialUpdate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Managed by <a class="el" href="classTNL_1_1GhostConnection.html" title="GhostConnection is a subclass of EventConnection that manages the transmission (ghosting)...">GhostConnection</a> - set to true when this is an initial update.  <a href="#aa23bf48466753be3b647021960617ff"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Friends</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#89952c4864e81b347f33b783bf8b57d9">GhostConnection</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#f0897312ef6d9cff1391e3cd365eb69c">GhostAlwaysObjectEvent</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html#73f92bd832fdeaba55e6f4ec7a3ccfd4">NetObjectRPCEvent</a></td></tr>

</table>
<hr><h2>Member Typedef Documentation</h2>
<a class="anchor" name="48b0d15649551fe170fee485b0d126bb"></a><!-- doxytag: member="TNL::NetObject::Parent" ref="48b0d15649551fe170fee485b0d126bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTNL_1_1Object.html">Object</a> <a class="el" href="classTNL_1_1Object.html">TNL::NetObject::Parent</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

<p>
Reimplemented in <a class="el" href="classTNLTest_1_1Player.html#b2aecae673bb04a2239b19dddf0c80ee">TNLTest::Player</a>, <a class="el" href="classTNLTest_1_1Building.html#2ea0dd8999dafcb828ff1fc07dd702ac">TNLTest::Building</a>, <a class="el" href="classZap_1_1CTFGameType.html#9bb6745a5208c9ed07057917f5d9b9e9">Zap::CTFGameType</a>, <a class="el" href="classZap_1_1EngineeredObject.html#88725c143e06c86b4d469c2635cbadc5">Zap::EngineeredObject</a>, <a class="el" href="classZap_1_1ForceFieldProjector.html#92ed95aeff7436e7438dfc1c0473ca69">Zap::ForceFieldProjector</a>, <a class="el" href="classZap_1_1Turret.html#a1c89dcf6ddd744e426f0e078209ef25">Zap::Turret</a>, <a class="el" href="classZap_1_1FlagItem.html#138d5222d101c19dfacdec543573d004">Zap::FlagItem</a>, <a class="el" href="classZap_1_1GameObject.html#7db898384778e78f06dfe92bcc0c6254">Zap::GameObject</a>, <a class="el" href="classZap_1_1GoalZone.html#9ec28e14fa0bf4b92ceb3701562097be">Zap::GoalZone</a>, <a class="el" href="classZap_1_1HuntersGameType.html#8da0be47dd4d7802fff51f724b4ac9ec">Zap::HuntersGameType</a>, <a class="el" href="classZap_1_1HuntersFlagItem.html#fdc6d23bd632a59fa431a75ea98a6f04">Zap::HuntersFlagItem</a>, <a class="el" href="classZap_1_1HuntersNexusObject.html#3ae96275c41d6a35f43e56e2ff45782f">Zap::HuntersNexusObject</a>, <a class="el" href="classZap_1_1PickupItem.html#ba046ab850fd97e64e818be2c302842f">Zap::PickupItem</a>, <a class="el" href="classZap_1_1GrenadeProjectile.html#99adfee26a3c8707bb9ca5312d3da004">Zap::GrenadeProjectile</a>, <a class="el" href="classZap_1_1Mine.html#e8f58116f34892ebd45becc233c143e8">Zap::Mine</a>, <a class="el" href="classZap_1_1RabbitGameType.html#0d70c4e472200e70db1ca942df2ccd5c">Zap::RabbitGameType</a>, <a class="el" href="classZap_1_1Ship.html#820711058a8840b3204db1cfcd11d843">Zap::Ship</a>, <a class="el" href="classZap_1_1SoccerGameType.html#f22031b4c1e6ca114ebf2482f474deb7">Zap::SoccerGameType</a>, and <a class="el" href="classZap_1_1SoccerBallItem.html#828b0e6298069c3fc9285929df80f75a">Zap::SoccerBallItem</a>.
</div>
</div><p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="d09d727c2d3fbf870a1ca33f4925d89f"></a><!-- doxytag: member="TNL::NetObject::NetFlag" ref="d09d727c2d3fbf870a1ca33f4925d89f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTNL_1_1NetObject.html#d09d727c2d3fbf870a1ca33f4925d89f">TNL::NetObject::NetFlag</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="d09d727c2d3fbf870a1ca33f4925d89fa2161af5b6aebc78c12e79be56406445"></a><!-- doxytag: member="IsGhost" ref="d09d727c2d3fbf870a1ca33f4925d89fa2161af5b6aebc78c12e79be56406445" args="" -->IsGhost</em>&nbsp;</td><td>
Set if this is a ghost. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="d09d727c2d3fbf870a1ca33f4925d89f470e75829d247485a3d3010c6551ff29"></a><!-- doxytag: member="ScopeLocal" ref="d09d727c2d3fbf870a1ca33f4925d89f470e75829d247485a3d3010c6551ff29" args="" -->ScopeLocal</em>&nbsp;</td><td>
If set, this object ghosts only to the local client. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="d09d727c2d3fbf870a1ca33f4925d89fdbb46327d5b781ebcd956ca3a8bd05b2"></a><!-- doxytag: member="Ghostable" ref="d09d727c2d3fbf870a1ca33f4925d89fdbb46327d5b781ebcd956ca3a8bd05b2" args="" -->Ghostable</em>&nbsp;</td><td>
Set if this object can ghost at all. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="d09d727c2d3fbf870a1ca33f4925d89fb50d254c287de4f9243c68bf6a58846f"></a><!-- doxytag: member="MaxNetFlagBit" ref="d09d727c2d3fbf870a1ca33f4925d89fb50d254c287de4f9243c68bf6a58846f" args="" -->MaxNetFlagBit</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="6e60ac3903380981362014078db112c3"></a><!-- doxytag: member="TNL::NetObject::NetObject" ref="6e60ac3903380981362014078db112c3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TNL::NetObject::NetObject           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a8df4763623a665f9d2c0d89f70d35e6"></a><!-- doxytag: member="TNL::NetObject::~NetObject" ref="a8df4763623a665f9d2c0d89f70d35e6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TNL::NetObject::~NetObject           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="049d4f6402a3792f88d3712dc7c7e249"></a><!-- doxytag: member="TNL::NetObject::isInitialUpdate" ref="049d4f6402a3792f88d3712dc7c7e249" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TNL::NetObject::isInitialUpdate           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if this pack/unpackUpdate is the initial one for the object. 
<p>

</div>
</div><p>
<a class="anchor" name="4d26a18a7cb7cbb0f0235a88567806a0"></a><!-- doxytag: member="TNL::NetObject::collapseDirtyList" ref="4d26a18a7cb7cbb0f0235a88567806a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void TNL::NetObject::collapseDirtyList           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
collapseDirtyList pushes all the mDirtyMaskBits down into the GhostInfo's for each object, and clears out the dirty list. 
<p>

</div>
</div><p>
<a class="anchor" name="ae6199a2b3b481cc6b62ada4db9614be"></a><!-- doxytag: member="TNL::NetObject::getRPCSourceConnection" ref="ae6199a2b3b481cc6b62ada4db9614be" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a>* TNL::NetObject::getRPCSourceConnection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the connection from which the current RPC method originated, or NULL if not currently within the processing of an RPC method call. 
<p>

</div>
</div><p>
<a class="anchor" name="f8e6ebb19349f27763a62e13b8785f30"></a><!-- doxytag: member="TNL::NetObject::setRPCDestConnection" ref="f8e6ebb19349f27763a62e13b8785f30" args="(GhostConnection *destConnection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void TNL::NetObject::setRPCDestConnection           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>destConnection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the connection to which all <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> RPCs will be destined. 
<p>
Calling this function with a NULL value will target <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> RPCs to every connection for which that object is currently ghosted. 
</div>
</div><p>
<a class="anchor" name="a1d10249d8ead78b30a30835ad4cc900"></a><!-- doxytag: member="TNL::NetObject::getRPCDestConnection" ref="a1d10249d8ead78b30a30835ad4cc900" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a>* TNL::NetObject::getRPCDestConnection           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the connection that serves as the destination of <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> RPC method calls. 
<p>

</div>
</div><p>
<a class="anchor" name="109bbc7cec4d57c9f0c1830c773fe600"></a><!-- doxytag: member="TNL::NetObject::onGhostAdd" ref="109bbc7cec4d57c9f0c1830c773fe600" args="(GhostConnection *theConnection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TNL::NetObject::onGhostAdd           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>theConnection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
onGhostAdd is called on the client side of a connection after the constructor and after the first call to unpackUpdate (the initial call). 
<p>
Returning true signifies no error - returning false causes the connection to abort. 
<p>
Reimplemented in <a class="el" href="classTNLTest_1_1Player.html#1dcb27f289c90c65d86d8107524bece6">TNLTest::Player</a>, <a class="el" href="classTNLTest_1_1Building.html#bf3d9860739a51dfd52077b02c108f74">TNLTest::Building</a>, and <a class="el" href="classZap_1_1GameObject.html#192450eed320765d1d4d77b9f3365e55">Zap::GameObject</a>.
</div>
</div><p>
<a class="anchor" name="d7d2b55015ce527a88eea1786899366a"></a><!-- doxytag: member="TNL::NetObject::onGhostRemove" ref="d7d2b55015ce527a88eea1786899366a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TNL::NetObject::onGhostRemove           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
onGhostRemove is called on the client side before the destructor when ghost has gone out of scope and is about to be deleted from the client. 
<p>

<p>
Reimplemented in <a class="el" href="classZap_1_1Ship.html#c03941a133370a5be7c75319d222403e">Zap::Ship</a>.
</div>
</div><p>
<a class="anchor" name="050a38bbae03ce5b0c88e2c4759de1fc"></a><!-- doxytag: member="TNL::NetObject::onGhostAvailable" ref="050a38bbae03ce5b0c88e2c4759de1fc" args="(GhostConnection *theConnection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TNL::NetObject::onGhostAvailable           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>theConnection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
onGhostAvailable is called on the server side after the server knows that the ghost is available and addressable via the getGhostIndex(). 
<p>

<p>
Reimplemented in <a class="el" href="classTNLTest_1_1Player.html#16a5aab28683b486694dcd1a9a0c356f">TNLTest::Player</a>, <a class="el" href="classZap_1_1GameType.html#648939f784ad34317cd7f9672421d178">Zap::GameType</a>, and <a class="el" href="classZap_1_1HuntersGameType.html#4523c79b065cd1f94ad72c7d8c76dfd8">Zap::HuntersGameType</a>.
</div>
</div><p>
<a class="anchor" name="1273616c155111f51bc3d1f8267e5293"></a><!-- doxytag: member="TNL::NetObject::setMaskBits" ref="1273616c155111f51bc3d1f8267e5293" args="(U32 orMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TNL::NetObject::setMaskBits           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td>
          <td class="paramname"> <em>orMask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notify the network system that one or more of this object's states have been changed. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is a server side call. It has no meaning for ghosts. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a17898f6a5e9dbc8460622bdb483765e"></a><!-- doxytag: member="TNL::NetObject::clearMaskBits" ref="a17898f6a5e9dbc8460622bdb483765e" args="(U32 orMask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TNL::NetObject::clearMaskBits           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td>
          <td class="paramname"> <em>orMask</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Notify the network system that one or more of its states does not need to be updated. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is a server side call. It has no meaning for ghosts. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3b5aaf4dae85007ace1afcab0da96448"></a><!-- doxytag: member="TNL::NetObject::getUpdatePriority" ref="3b5aaf4dae85007ace1afcab0da96448" args="(NetObject *scopeObject, U32 updateMask, S32 updateSkips)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a> TNL::NetObject::getUpdatePriority           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTNL_1_1NetObject.html">NetObject</a> *&nbsp;</td>
          <td class="paramname"> <em>scopeObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td>
          <td class="paramname"> <em>updateMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38">S32</a>&nbsp;</td>
          <td class="paramname"> <em>updateSkips</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Called to determine the relative update priority of an object. 
<p>
All objects that are in scope and that have out of date states are queried and sorted by priority before being updated. If there is not enough room in a single packet for all out of date objects, the skipped objects will have an incremented updateSkips the next time that connection prepares to send a packet. Typically the update priority is scaled by updateSkips so that as data becomes stale, it becomes more of a priority to update. 
<p>
Reimplemented in <a class="el" href="classZap_1_1GameObject.html#00d4cdcddad417545aabe7fc8cd200fd">Zap::GameObject</a>.
</div>
</div><p>
<a class="anchor" name="5ae1ab5301e16b7659b0839b120150a0"></a><!-- doxytag: member="TNL::NetObject::packUpdate" ref="5ae1ab5301e16b7659b0839b120150a0" args="(GhostConnection *connection, U32 updateMask, BitStream *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> TNL::NetObject::packUpdate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td>
          <td class="paramname"> <em>updateMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTNL_1_1BitStream.html">BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the object's state to a packet. 
<p>
packUpdate is called on an object when it is to be written into a packet stream for transmission to the client. The updateMask parameter contains the out-of-date state mask for the object. The initial update mask for any object to a client will always be 0xFFFFFFFF, signifying that all states are out of date. It is often useful to check for this mask, to write one-time initialization information for that object. 
<p>
Reimplemented in <a class="el" href="classTNLTest_1_1Player.html#910851be600699911917f84da6ce9f86">TNLTest::Player</a>, <a class="el" href="classTNLTest_1_1Building.html#1bb025a86380698c5e1999d5e9b2f8d5">TNLTest::Building</a>, <a class="el" href="classZap_1_1EngineeredObject.html#401be1a0ff8ca68152d9e804c3c79565">Zap::EngineeredObject</a>, <a class="el" href="classZap_1_1ForceField.html#15a372e5ba2c691aa6e7fe6eceb72119">Zap::ForceField</a>, <a class="el" href="classZap_1_1Turret.html#5107b2407bfc5828553885c67d6e5f9e">Zap::Turret</a>, <a class="el" href="classZap_1_1FlagItem.html#d890829e2a34da775fd3311b231766f5">Zap::FlagItem</a>, <a class="el" href="classZap_1_1GoalZone.html#6c60c48b845af9fac04c4eb5826bcbf2">Zap::GoalZone</a>, <a class="el" href="classZap_1_1HuntersFlagItem.html#2344476ad6ed98b364639f5eb5fce98a">Zap::HuntersFlagItem</a>, <a class="el" href="classZap_1_1HuntersNexusObject.html#d1d1634298eb064e9c36803579e57705">Zap::HuntersNexusObject</a>, <a class="el" href="classZap_1_1Item.html#3ac19533e31302e8943bf0f36638971c">Zap::Item</a>, <a class="el" href="classZap_1_1PickupItem.html#568b75fc4221691857416643be4ffc57">Zap::PickupItem</a>, <a class="el" href="classZap_1_1Projectile.html#0012d3a4c9801dc64d38be4fe3f9f580">Zap::Projectile</a>, <a class="el" href="classZap_1_1GrenadeProjectile.html#d6a46dfaf94e6775e77fe28a739fbe6c">Zap::GrenadeProjectile</a>, <a class="el" href="classZap_1_1Mine.html#c7b59080ed0bb7a55f9b33f87b385359">Zap::Mine</a>, <a class="el" href="classZap_1_1Ship.html#fe49fda6d11db217af038a74f36ca83b">Zap::Ship</a>, and <a class="el" href="classZap_1_1Teleporter.html#587b71c1ebe81ca8c4f7cc5b127185f4">Zap::Teleporter</a>.
</div>
</div><p>
<a class="anchor" name="f3eda283fef93bad7b3b7f5d8cce28e8"></a><!-- doxytag: member="TNL::NetObject::unpackUpdate" ref="f3eda283fef93bad7b3b7f5d8cce28e8" args="(GhostConnection *connection, BitStream *stream)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TNL::NetObject::unpackUpdate           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTNL_1_1BitStream.html">BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>stream</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unpack data written by <a class="el" href="classTNL_1_1NetObject.html#5ae1ab5301e16b7659b0839b120150a0" title="Write the object's state to a packet.">packUpdate()</a>. 
<p>
unpackUpdate is called on the client to read an update out of a packet's bit stream. Because the update mask is not encoded by the network system directly, each unpack update function will have to determine from the bit stream which states are being updated. 
<p>
Reimplemented in <a class="el" href="classTNLTest_1_1Player.html#f5271a8d134b3d622c56be0dc3dbf1c0">TNLTest::Player</a>, <a class="el" href="classTNLTest_1_1Building.html#404821e2aa1d4f4cb2808dd8c9ab634a">TNLTest::Building</a>, <a class="el" href="classZap_1_1EngineeredObject.html#41f9e4f410060ba4eb54327602728f1c">Zap::EngineeredObject</a>, <a class="el" href="classZap_1_1ForceField.html#e5d45966af2fa816d26fb4450f3c2128">Zap::ForceField</a>, <a class="el" href="classZap_1_1Turret.html#68b64ab9f278beadf0b7089e8a1b036d">Zap::Turret</a>, <a class="el" href="classZap_1_1FlagItem.html#2e6513e1327883c2686008af22158ba8">Zap::FlagItem</a>, <a class="el" href="classZap_1_1GoalZone.html#22ae24b1ee51843d222b8262810364e5">Zap::GoalZone</a>, <a class="el" href="classZap_1_1HuntersFlagItem.html#0a9059a79f918b86dfff0b62f979920a">Zap::HuntersFlagItem</a>, <a class="el" href="classZap_1_1HuntersNexusObject.html#1164531a064a861b77266c4e4a64d8da">Zap::HuntersNexusObject</a>, <a class="el" href="classZap_1_1Item.html#92eeee671939d3c3bef4681fc8bc461b">Zap::Item</a>, <a class="el" href="classZap_1_1PickupItem.html#ed9354f76141fd09aaeac004d1016b58">Zap::PickupItem</a>, <a class="el" href="classZap_1_1Projectile.html#9e3fb35ffa96bac58be61e88fef70a18">Zap::Projectile</a>, <a class="el" href="classZap_1_1GrenadeProjectile.html#c395cd57ea6d899a356136481b3850ec">Zap::GrenadeProjectile</a>, <a class="el" href="classZap_1_1Mine.html#9c233748869ca5f8e9485725719c33ca">Zap::Mine</a>, <a class="el" href="classZap_1_1Ship.html#d6f34f37b2710e89235e2cf8ccd592e2">Zap::Ship</a>, and <a class="el" href="classZap_1_1Teleporter.html#2195cce11b7afa60567e76fd5aec1a09">Zap::Teleporter</a>.
</div>
</div><p>
<a class="anchor" name="81e9010708e91f3aa17fbd562370d49e"></a><!-- doxytag: member="TNL::NetObject::performScopeQuery" ref="81e9010708e91f3aa17fbd562370d49e" args="(GhostConnection *connection)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TNL::NetObject::performScopeQuery           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a> *&nbsp;</td>
          <td class="paramname"> <em>connection</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
For a scope object, determine what is in scope. 
<p>
performScopeQuery is called on a NetConnection's scope object to determine which objects in the world are in scope for that connection. 
<p>
Reimplemented in <a class="el" href="classTNLTest_1_1Player.html#7146c57381e26f306d6a27fbead70ad7">TNLTest::Player</a>, and <a class="el" href="classZap_1_1GameType.html#fd29975fa0887f9d6ac078b6c0ebe036">Zap::GameType</a>.
</div>
</div><p>
<a class="anchor" name="7233fda2cc4312c436f8e97b1bed75ef"></a><!-- doxytag: member="TNL::NetObject::getNetIndex" ref="7233fda2cc4312c436f8e97b1bed75ef" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> TNL::NetObject::getNetIndex           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
getNetIndex returns the index tag used to identify the server copy of a client object. 
<p>

</div>
</div><p>
<a class="anchor" name="0395334cc77ffd098be735aaa59b6518"></a><!-- doxytag: member="TNL::NetObject::isGhost" ref="0395334cc77ffd098be735aaa59b6518" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TNL::NetObject::isGhost           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
isGhost returns true if this object is a ghost of a server object. 
<p>

</div>
</div><p>
<a class="anchor" name="47e9d4503e8ba162697ff4be86d4f241"></a><!-- doxytag: member="TNL::NetObject::isScopeLocal" ref="47e9d4503e8ba162697ff4be86d4f241" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TNL::NetObject::isScopeLocal           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
isScopeLocal returns true if this object is scoped always to the local client. 
<p>

</div>
</div><p>
<a class="anchor" name="a0309814f89bb59720380752515fd251"></a><!-- doxytag: member="TNL::NetObject::isGhostable" ref="a0309814f89bb59720380752515fd251" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TNL::NetObject::isGhostable           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
isGhostable returns true if this object can be ghosted to any clients. 
<p>

</div>
</div><p>
<a class="anchor" name="d7800c4ef8bbff37231c83fbf1751be9"></a><!-- doxytag: member="TNL::NetObject::getHashId" ref="d7800c4ef8bbff37231c83fbf1751be9" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> TNL::NetObject::getHashId           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return a hash for this object. 
<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This is based on its location in memory. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e548c585cc77350525a991687c1dd794"></a><!-- doxytag: member="TNL::NetObject::postRPCEvent" ref="e548c585cc77350525a991687c1dd794" args="(NetObjectRPCEvent *theEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TNL::NetObject::postRPCEvent           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTNL_1_1NetObjectRPCEvent.html">NetObjectRPCEvent</a> *&nbsp;</td>
          <td class="paramname"> <em>theEvent</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Internal method called by <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> RPC events when they are packed. 
<p>

</div>
</div><p>
<hr><h2>Friends And Related Function Documentation</h2>
<a class="anchor" name="89952c4864e81b347f33b783bf8b57d9"></a><!-- doxytag: member="TNL::NetObject::GhostConnection" ref="89952c4864e81b347f33b783bf8b57d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="f0897312ef6d9cff1391e3cd365eb69c"></a><!-- doxytag: member="TNL::NetObject::GhostAlwaysObjectEvent" ref="f0897312ef6d9cff1391e3cd365eb69c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class GhostAlwaysObjectEvent<code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="73f92bd832fdeaba55e6f4ec7a3ccfd4"></a><!-- doxytag: member="TNL::NetObject::NetObjectRPCEvent" ref="73f92bd832fdeaba55e6f4ec7a3ccfd4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTNL_1_1NetObjectRPCEvent.html">NetObjectRPCEvent</a><code> [friend]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="5e51ba1758c711016ac4d1a578462316"></a><!-- doxytag: member="TNL::NetObject::mPrevDirtyList" ref="5e51ba1758c711016ac4d1a578462316" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTNL_1_1NetObject.html">NetObject</a>* <a class="el" href="classTNL_1_1NetObject.html#5e51ba1758c711016ac4d1a578462316">TNL::NetObject::mPrevDirtyList</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="bde3b16fb4b2d8ae1cf5dbac284a1276"></a><!-- doxytag: member="TNL::NetObject::mNextDirtyList" ref="bde3b16fb4b2d8ae1cf5dbac284a1276" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTNL_1_1NetObject.html">NetObject</a>* <a class="el" href="classTNL_1_1NetObject.html#bde3b16fb4b2d8ae1cf5dbac284a1276">TNL::NetObject::mNextDirtyList</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="05043543d90c36fe613bbc51141060ee"></a><!-- doxytag: member="TNL::NetObject::mDirtyMaskBits" ref="05043543d90c36fe613bbc51141060ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> <a class="el" href="classTNL_1_1NetObject.html#05043543d90c36fe613bbc51141060ee">TNL::NetObject::mDirtyMaskBits</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="187c2b97fe60531ba5586286f5a2aed2"></a><!-- doxytag: member="TNL::NetObject::mDirtyList" ref="187c2b97fe60531ba5586286f5a2aed2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTNL_1_1NetObject.html">NetObject</a>* <a class="el" href="classTNL_1_1NetObject.html#187c2b97fe60531ba5586286f5a2aed2">TNL::NetObject::mDirtyList</a><code> [static, private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="56df1ec7fea03e881cd501191117b1e5"></a><!-- doxytag: member="TNL::NetObject::mNetIndex" ref="56df1ec7fea03e881cd501191117b1e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> <a class="el" href="classTNL_1_1NetObject.html#56df1ec7fea03e881cd501191117b1e5">TNL::NetObject::mNetIndex</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The index of this ghost on the other side of the connection. 
<p>

</div>
</div><p>
<a class="anchor" name="6564e3aa5fc664c99781334ef1bc0405"></a><!-- doxytag: member="TNL::NetObject::mFirstObjectRef" ref="6564e3aa5fc664c99781334ef1bc0405" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTNL_1_1GhostInfo.html">GhostInfo</a>* <a class="el" href="classTNL_1_1NetObject.html#6564e3aa5fc664c99781334ef1bc0405">TNL::NetObject::mFirstObjectRef</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Head of the linked list of GhostInfos for this object. 
<p>

<p>
Reimplemented from <a class="el" href="classTNL_1_1Object.html#e340807cd9e99d31edb0fca968e9983a">TNL::Object</a>.
</div>
</div><p>
<a class="anchor" name="aa23bf48466753be3b647021960617ff"></a><!-- doxytag: member="TNL::NetObject::mIsInitialUpdate" ref="aa23bf48466753be3b647021960617ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classTNL_1_1NetObject.html#aa23bf48466753be3b647021960617ff">TNL::NetObject::mIsInitialUpdate</a><code> [static, private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Managed by <a class="el" href="classTNL_1_1GhostConnection.html" title="GhostConnection is a subclass of EventConnection that manages the transmission (ghosting)...">GhostConnection</a> - set to true when this is an initial update. 
<p>

</div>
</div><p>
<a class="anchor" name="ad0b9a995363d64c3e6c1214c95a99b9"></a><!-- doxytag: member="TNL::NetObject::mServerObject" ref="ad0b9a995363d64c3e6c1214c95a99b9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTNL_1_1SafePtr.html">SafePtr</a>&lt;<a class="el" href="classTNL_1_1NetObject.html">NetObject</a>&gt; <a class="el" href="classTNL_1_1NetObject.html#ad0b9a995363d64c3e6c1214c95a99b9">TNL::NetObject::mServerObject</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Direct pointer to the parent object on the server if it is a local connection. 
<p>

</div>
</div><p>
<a class="anchor" name="340fd14b3ab1badf4ef77c8a647af3a5"></a><!-- doxytag: member="TNL::NetObject::mOwningConnection" ref="340fd14b3ab1badf4ef77c8a647af3a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a>* <a class="el" href="classTNL_1_1NetObject.html#340fd14b3ab1badf4ef77c8a647af3a5">TNL::NetObject::mOwningConnection</a><code> [private]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The connection that owns this ghost, if it's a ghost. 
<p>

</div>
</div><p>
<a class="anchor" name="7cab04892c210057e9ab764e50c21410"></a><!-- doxytag: member="TNL::NetObject::mNetFlags" ref="7cab04892c210057e9ab764e50c21410" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTNL_1_1BitSet32.html">BitSet32</a> <a class="el" href="classTNL_1_1NetObject.html#7cab04892c210057e9ab764e50c21410">TNL::NetObject::mNetFlags</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flags field describing this object, from NetFlag. 
<p>

</div>
</div><p>
<a class="anchor" name="b091359493559597b7da1b568e4ca201"></a><!-- doxytag: member="TNL::NetObject::mRPCSourceConnection" ref="b091359493559597b7da1b568e4ca201" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a>* <a class="el" href="classTNL_1_1NetObject.html#b091359493559597b7da1b568e4ca201">TNL::NetObject::mRPCSourceConnection</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RPC method source connection. 
<p>

</div>
</div><p>
<a class="anchor" name="2c90cd93b0d1ac79552a0421ac1914ef"></a><!-- doxytag: member="TNL::NetObject::mRPCDestConnection" ref="2c90cd93b0d1ac79552a0421ac1914ef" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a>* <a class="el" href="classTNL_1_1NetObject.html#2c90cd93b0d1ac79552a0421ac1914ef">TNL::NetObject::mRPCDestConnection</a><code> [static, protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> RPC method destination connection. 
<p>

</div>
</div><p>
			<div class="footer">
			Documentation hosted by <a href="http://sourceforge.net/">SourceForge.net</a><br>
			<small><b>All Rights Reserved <A href="http://www.garagegames.com/">GarageGames.com, Inc.</a> 1999-2004</b></small><br>
            <small>Documentation auto-magically Generated with <a href='http://www.doxygen.org' target='_blank'>Doxygen 1.5.2</a></small>
			</div>
		</TD>
	</TR>
</TABLE>
</BODY>
</HTML>
