<HTML>
<HEAD>
<TITLE>OpenTNL - TNL: TNL Namespace Reference</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<link href="doco.css" rel="stylesheet" type="text/css">
</HEAD>
<BODY BGCOLOR=#FFFFFF LEFTMARGIN=0 TOPMARGIN=0 MARGINWIDTH=0 MARGINHEIGHT=0>
<TABLE WIDTH=100% height="100%" BORDER=0 CELLPADDING=0 CELLSPACING=0>
	<TR height="47">
		<TD width="169" height="46"><a href="http://www.opentnl.org/"><IMG SRC="images/layout_tnllogo.gif" WIDTH=169 HEIGHT=47 ALT="" border=0></a></TD>
		<TD width="100%" height="46" BGCOLOR=#322900 valign=top><IMG SRC="images/layout_topbar.gif" HEIGHT=47 ALT=""></TD>
	</TR>
	<TR>
		<TD width="169" bgcolor="#1A1B4D" valign=top nowrap>
			<table WIDTH=169 BORDER=0 CELLPADDING=0 CELLSPACING=0 bgcolor="#1A1B4D">
			<tr WIDTH=169 HEIGHT=20>
				<td WIDTH=169 HEIGHT=20 valign=top>
				<IMG SRC="images/layout_left_tnl.gif" WIDTH=169 HEIGHT=20 ALT="">
				</td>
			</tr>
			<tr>
				<td>
				<a href="http://www.opentnl.org/index.php"><IMG SRC="images/layout_left_news.gif" ALT="News" WIDTH=169 HEIGHT=30 border="0"></a>
				<a href="http://sourceforge.net/projects/opentnl"><img src="images/layout_left_sf.gif" width="169" height="30" border="0" alt="SF.net Project"></a>
				<a href="http://www.opentnl.org/faq.php"><IMG SRC="images/layout_left_faq.gif" ALT="Frequently Asked Questions" WIDTH=169 HEIGHT=30 border="0"></a>
				<a href="http://www.opentnl.org/docs.php"><IMG SRC="images/layout_left_documentation.gif" ALT="Documentation" WIDTH=169 HEIGHT=30 border="0"></a>
				<a href="http://www.opentnl.org/download.php"><IMG SRC="images/layout_left_downloads.gif" ALT="Downloads" WIDTH=169 HEIGHT=30 border="0"></a>
				<a href="http://sourceforge.net/mail/?group_id=106342"><IMG SRC="images/layout_left_mailing.gif" ALT="Mailing Lists" WIDTH=169 HEIGHT=30 border="0"></a>
				<a href="http://www.opentnl.org/contribute.php"><IMG SRC="images/layout_left_contributors.gif" ALT="How to Contribute" WIDTH=169 HEIGHT=30 border="0"></a>

				<p align="center">
				<a href="http://sourceforge.net">
				<img src="http://sourceforge.net/sflogo.php?group_id=opentnl&amp;type=2" width="125" height="37" border="0" alt="SourceForge.net Logo" />
				</a>
				<br>
				<br>
				<a href="http://www.garagegames.com/">
				<img src="images/gglogo.png" height=100 width=100 border=0 ALT="Changing the way games are made and played.">
				</a>
				</p>

				</td>
			</tr>
			</table>
		</TD>
		<TD width=100% align="left" valign="top">
<div class="header">
	<div class="nav">TNL 1.5.0 - 29 May 2007</div>
	<div class="index">
	<a href="index.html">Main Page</a>
	<a href="modules.html">Modules</a>
	<a href="namespaces.html">Namespaces</a>
	<a href="hierarchy.html">C++ Classes</a>
	<a href="annotated.html">Compound List</a>
	<a href="files.html">File List</a>
	<a href="functions.html">Index</a>
	</div>
</div>
      <div class="article">
	<div class="title">
		TNL: TNL Namespace Reference
	</div>

	<div class="body">
<!-- Generated by Doxygen 1.5.2 -->
<h1>TNL Namespace Reference</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Global namespace for all <a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a> classes. 
<p>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1Assert.html">Assert</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTNL_1_1Assert.html" title="Assert functions for validating proper program state.">Assert</a> functions for validating proper program state.  <a href="classTNL_1_1Assert.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1AsymmetricKey.html">AsymmetricKey</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1BitSet32.html">BitSet32</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Represents a word of bits.  <a href="classTNL_1_1BitSet32.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1Point3F.html">Point3F</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structTNL_1_1Point3F.html" title="Point3F is used by BitStream for transmitting 3D points and vectors.">Point3F</a> is used by <a class="el" href="classTNL_1_1BitStream.html" title="BitStream provides a bit-level stream interface to a data buffer.">BitStream</a> for transmitting 3D points and vectors.  <a href="structTNL_1_1Point3F.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1BitStream.html">BitStream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTNL_1_1BitStream.html" title="BitStream provides a bit-level stream interface to a data buffer.">BitStream</a> provides a bit-level stream interface to a data buffer.  <a href="classTNL_1_1BitStream.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1PacketStream.html">PacketStream</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTNL_1_1PacketStream.html" title="PacketStream provides a network interface to the BitStream for easy construction...">PacketStream</a> provides a network interface to the <a class="el" href="classTNL_1_1BitStream.html" title="BitStream provides a bit-level stream interface to a data buffer.">BitStream</a> for easy construction of data packets.  <a href="classTNL_1_1PacketStream.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1ByteBuffer.html">ByteBuffer</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1Certificate.html">Certificate</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classTNL_1_1Certificate.html" title="The Certificate class manages a digitally signed certificate.">Certificate</a> class manages a digitally signed certificate.  <a href="classTNL_1_1Certificate.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1ClientPuzzleManager.html">ClientPuzzleManager</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classTNL_1_1ClientPuzzleManager.html" title="The ClientPuzzleManager class issues, solves and validates client puzzles for connection...">ClientPuzzleManager</a> class issues, solves and validates client puzzles for connection authentication.  <a href="classTNL_1_1ClientPuzzleManager.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1ConnectionStringTable.html">ConnectionStringTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTNL_1_1ConnectionStringTable.html" title="ConnectionStringTable is a helper class to EventConnection for reducing duplicated...">ConnectionStringTable</a> is a helper class to <a class="el" href="classTNL_1_1EventConnection.html" title="EventConnection is a NetConnection subclass used for sending guaranteed and unguaranteed...">EventConnection</a> for reducing duplicated string data sends.  <a href="classTNL_1_1ConnectionStringTable.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1DataChunker.html">DataChunker</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implements a chunked data allocater.  <a href="classTNL_1_1DataChunker.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1ClassChunker.html">ClassChunker</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Templatized data chunker class with proper construction and destruction of its elements.  <a href="classTNL_1_1ClassChunker.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1EventConnection.html">EventConnection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTNL_1_1EventConnection.html" title="EventConnection is a NetConnection subclass used for sending guaranteed and unguaranteed...">EventConnection</a> is a <a class="el" href="classTNL_1_1NetConnection.html" title="TNL network connection base class.">NetConnection</a> subclass used for sending guaranteed and unguaranteed event packages across a connection.  <a href="classTNL_1_1EventConnection.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1GhostConnection.html">GhostConnection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTNL_1_1GhostConnection.html" title="GhostConnection is a subclass of EventConnection that manages the transmission (ghosting)...">GhostConnection</a> is a subclass of <a class="el" href="classTNL_1_1EventConnection.html" title="EventConnection is a NetConnection subclass used for sending guaranteed and unguaranteed...">EventConnection</a> that manages the transmission (ghosting) and updating of NetObjects over a connection.  <a href="classTNL_1_1GhostConnection.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1GhostInfo.html">GhostInfo</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Each <a class="el" href="structTNL_1_1GhostInfo.html" title="Each GhostInfo structure tracks the state of a single NetObject's ghost for a single...">GhostInfo</a> structure tracks the state of a single NetObject's ghost for a single <a class="el" href="classTNL_1_1GhostConnection.html" title="GhostConnection is a subclass of EventConnection that manages the transmission (ghosting)...">GhostConnection</a>.  <a href="structTNL_1_1GhostInfo.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1Journal.html">Journal</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classTNL_1_1Journal.html" title="The Journal class represents the recordable entry point(s) into program execution...">Journal</a> class represents the recordable entry point(s) into program execution.  <a href="classTNL_1_1Journal.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1JournalEntryRecord.html">JournalEntryRecord</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1JournalToken.html">JournalToken</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1JournalBlockTypeToken.html">JournalBlockTypeToken</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1LogConsumer.html">LogConsumer</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTNL_1_1LogConsumer.html" title="LogConsumer is the base class for the message logging system in TNL.">LogConsumer</a> is the base class for the message logging system in <a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a>.  <a href="classTNL_1_1LogConsumer.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1LogType.html">LogType</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1LogTypeRef.html">LogTypeRef</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1Functor.html">Functor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for <a class="el" href="structTNL_1_1FunctorDecl.html" title="FunctorDecl template class.">FunctorDecl</a> template classes.  <a href="structTNL_1_1Functor.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl.html">FunctorDecl</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structTNL_1_1FunctorDecl.html" title="FunctorDecl template class.">FunctorDecl</a> template class.  <a href="structTNL_1_1FunctorDecl.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetClassRep.html">NetClassRep</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTNL_1_1NetClassRep.html" title="NetClassRep class instances represent each declared NetClass and are used to construct...">NetClassRep</a> class instances represent each declared NetClass and are used to construct object instances.  <a href="classTNL_1_1NetClassRep.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetClassRepInstance.html">NetClassRepInstance</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTNL_1_1NetClassRepInstance.html" title="NetClassRepInstance - one of these templates is instantiated for each class that...">NetClassRepInstance</a> - one of these templates is instantiated for each class that is declared via the IMPLEMENT_* macros below.  <a href="classTNL_1_1NetClassRepInstance.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1Object.html">Object</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for all <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a>, <a class="el" href="classTNL_1_1NetEvent.html" title="An event to be sent over the network.">NetEvent</a>, <a class="el" href="classTNL_1_1NetConnection.html" title="TNL network connection base class.">NetConnection</a> and <a class="el" href="classTNL_1_1NetInterface.html" title="NetInterface class.">NetInterface</a> instances.  <a href="classTNL_1_1Object.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1RefObjectRef.html">RefObjectRef</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for <a class="el" href="classTNL_1_1Object.html" title="Base class for all NetObject, NetEvent, NetConnection and NetInterface instances...">Object</a> reference counting.  <a href="classTNL_1_1RefObjectRef.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1RefPtr.html">RefPtr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reference counted object template pointer class.  <a href="classTNL_1_1RefPtr.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1SafeObjectRef.html">SafeObjectRef</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for <a class="el" href="classTNL_1_1Object.html" title="Base class for all NetObject, NetEvent, NetConnection and NetInterface instances...">Object</a> safe pointers.  <a href="classTNL_1_1SafeObjectRef.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1SafePtr.html">SafePtr</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Safe object template pointer class.  <a href="classTNL_1_1SafePtr.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1NetConnectionRep.html">NetConnectionRep</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structTNL_1_1NetConnectionRep.html" title="NetConnectionRep maintians a linked list of valid connection classes.">NetConnectionRep</a> maintians a linked list of valid connection classes.  <a href="structTNL_1_1NetConnectionRep.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1ConnectionParameters.html">ConnectionParameters</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">All data associated with the negotiation of the connection.  <a href="structTNL_1_1ConnectionParameters.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetConnection.html">NetConnection</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a> network connection base class.  <a href="classTNL_1_1NetConnection.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetEvent.html">NetEvent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An event to be sent over the network.  <a href="classTNL_1_1NetEvent.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetInterface.html">NetInterface</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="classTNL_1_1NetInterface.html" title="NetInterface class.">NetInterface</a> class.  <a href="classTNL_1_1NetInterface.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObject.html">NetObject</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Superclass for ghostable networked objects.  <a href="classTNL_1_1NetObject.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1NetObjectRPCEvent.html">NetObjectRPCEvent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Event class for handling RPC method invocations on NetObjects.  <a href="classTNL_1_1NetObjectRPCEvent.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1StringTableEntry.html">StringTableEntry</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classTNL_1_1StringTableEntry.html" title="The StringTableEntry class encapsulates an entry in the network StringTable.">StringTableEntry</a> class encapsulates an entry in the network <a class="el" href="namespaceTNL_1_1StringTable.html" title="A global table for the hashing and tracking of network strings.">StringTable</a>.  <a href="classTNL_1_1StringTableEntry.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1Nonce.html">Nonce</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1RPCEvent.html">RPCEvent</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Base class for RPC events.  <a href="classTNL_1_1RPCEvent.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1StringData.html">StringData</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1StringPtr.html">StringPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1SymmetricCipher.html">SymmetricCipher</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Class for symmetric encryption of data across a connection.  <a href="classTNL_1_1SymmetricCipher.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1Semaphore.html">Semaphore</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceTNL_1_1Platform.html" title="Platform specific functionality is gathered here to enable easier porting.">Platform</a> independent semaphore class.  <a href="classTNL_1_1Semaphore.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1Mutex.html">Mutex</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceTNL_1_1Platform.html" title="Platform specific functionality is gathered here to enable easier porting.">Platform</a> independent Mutual Exclusion implementation.  <a href="classTNL_1_1Mutex.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1Thread.html">Thread</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceTNL_1_1Platform.html" title="Platform specific functionality is gathered here to enable easier porting.">Platform</a> independent <a class="el" href="classTNL_1_1Thread.html" title="Platform independent Thread class.">Thread</a> class.  <a href="classTNL_1_1Thread.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1ThreadStorage.html">ThreadStorage</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceTNL_1_1Platform.html" title="Platform specific functionality is gathered here to enable easier porting.">Platform</a> independent per-thread storage class.  <a href="classTNL_1_1ThreadStorage.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1ThreadQueue.html">ThreadQueue</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Managing object for a queue of worker threads that pass messages back and forth to the main thread.  <a href="classTNL_1_1ThreadQueue.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1NetType.html">NetType</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structTNL_1_1NetType.html" title="NetType serves as a base class for all bit-compressed versions of the base types...">NetType</a> serves as a base class for all bit-compressed versions of the base types that can be transmitted using TNL's RPC mechanism.  <a href="structTNL_1_1NetType.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1Int.html">Int</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned integer bit-level RPC template wrapper.  <a href="structTNL_1_1Int.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1SignedInt.html">SignedInt</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Signed integer bit-level RPC template wrapper.  <a href="structTNL_1_1SignedInt.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1Float.html">Float</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Floating point 0.  <a href="structTNL_1_1Float.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1SignedFloat.html">SignedFloat</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Floating point -1.  <a href="structTNL_1_1SignedFloat.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1RangedU32.html">RangedU32</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unsigned ranged integer bit-level RPC template wrapper.  <a href="structTNL_1_1RangedU32.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1Address.html">Address</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Representation of a network address.  <a href="structTNL_1_1Address.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1IPAddress.html">IPAddress</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packed representaion of an <a class="el" href="structTNL_1_1IPAddress.html" title="Packed representaion of an IPAddress.">IPAddress</a>.  <a href="structTNL_1_1IPAddress.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1Socket.html">Socket</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="classTNL_1_1Socket.html" title="The Socket class encapsulates a platform's network socket.">Socket</a> class encapsulates a platform's network socket.  <a href="classTNL_1_1Socket.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1VectorRep.html">VectorRep</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="structTNL_1_1VectorRep.html" title="VectorRep is an image of a Vector template object that is used for marshalling and...">VectorRep</a> is an image of a <a class="el" href="classTNL_1_1Vector.html" title="A dynamic array template class.">Vector</a> template object that is used for marshalling and unmarshalling Vectors across RPCs.  <a href="structTNL_1_1VectorRep.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTNL_1_1Vector.html">Vector</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A dynamic array template class.  <a href="classTNL_1_1Vector.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl_3_01void(T_1_1_5)()_4.html">FunctorDecl&lt; void(T::*)()&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl_3_01void(T_1_1_5)(A)_4.html">FunctorDecl&lt; void(T::*)(A)&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl_3_01void(T_1_1_5)(A_00_01B)_4.html">FunctorDecl&lt; void(T::*)(A, B)&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl_3_01void(T_1_1_5)(A_00_01B_00_01C)_4.html">FunctorDecl&lt; void(T::*)(A, B, C)&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl_3_01void(T_1_1_5)(A_00_01B_00_01C_00_01D)_4.html">FunctorDecl&lt; void(T::*)(A, B, C, D)&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl_3_01void(T_1_1_5)(A_00_01B_00_01C_00_01D_00_01E)_4.html">FunctorDecl&lt; void(T::*)(A, B, C, D, E)&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl_3_01void(T_1_1_5)(A_00_01B_00_01C_00_01D_00_01E_00_01F)_4.html">FunctorDecl&lt; void(T::*)(A, B, C, D, E, F)&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl_3_01void(T_1_1_5)(A_00_01B_00_01C_00_01D_00_01E_00_01F_00_01G)_4.html">FunctorDecl&lt; void(T::*)(A, B, C, D, E, F, G)&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl_3_01void(T_1_1_5)(A_00_01B_00_01C_00_01D_00_01E_00_01F_00_01G_00_01H)_4.html">FunctorDecl&lt; void(T::*)(A, B, C, D, E, F, G, H)&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl_3_01void(T_1_1_5)(A_00_01B_00_01C_00_01D_00_01E_00_01F_00_01G_00_01H_00_01I)_4.html">FunctorDecl&lt; void(T::*)(A, B, C, D, E, F, G, H, I)&gt;</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTNL_1_1FunctorDecl_3_01void(T_1_1_5)(A_00_01B_00_01C_00_01D_00_01E_00_01F_00_01G_00_01H_00_01I_00_01J)_4.html">FunctorDecl&lt; void(T::*)(A, B, C, D, E, F, G, H, I, J)&gt;</a></td></tr>

<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL_1_1HuffmanStringProcessor.html">HuffmanStringProcessor</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceTNL_1_1HuffmanStringProcessor.html" title="HuffmanStringProcessor does Huffman coding on strings written into BitStream objects...">HuffmanStringProcessor</a> does Huffman coding on strings written into <a class="el" href="classTNL_1_1BitStream.html" title="BitStream provides a bit-level stream interface to a data buffer.">BitStream</a> objects. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL_1_1StringTable.html">StringTable</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A global table for the hashing and tracking of network strings. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL_1_1Platform.html">Platform</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><a class="el" href="namespaceTNL_1_1Platform.html" title="Platform specific functionality is gathered here to enable easier porting.">Platform</a> specific functionality is gathered here to enable easier porting. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL_1_1Random.html">Random</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The <a class="el" href="namespaceTNL_1_1Random.html" title="The Random namespace is an interface to a cryptographically secure pseudo random...">Random</a> namespace is an interface to a cryptographically secure pseudo random number generator (PRNG). <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classTNL_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classTNL_1_1AsymmetricKey.html">AsymmetricKey</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#be6c1cf7e7d16e13ca09ee2aa7e43ea6">AsymmetricKeyPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="classTNL_1_1RefPtr.html">RefPtr</a>&lt; <a class="el" href="classTNL_1_1ByteBuffer.html">ByteBuffer</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#e6144f462fa5173cd86fcb1f181a6640">ByteBufferPtr</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef const <a class="el" href="classTNL_1_1ByteBuffer.html">ByteBuffer</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#fd83cd07117d7fceea78779feb72fcec">ByteBufferRef</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#652eaee5cff7a9386d961dea6ed03b99">StringTableEntryId</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef const <a class="el" href="classTNL_1_1StringTableEntry.html">StringTableEntry</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#d08d8c0b3cd49c84a970ecee83927089">StringTableEntryRef</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef signed char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicTypes.html#ge6994d04641f3d1fdbe7a22724117c74">S8</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiler independent signed char (8bit integer).  <a href="group__BasicTypes.html#ge6994d04641f3d1fdbe7a22724117c74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicTypes.html#g64211cf47ad8b6d7d57960e40ea8de67">U8</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiler independent unsigned char (8bit integer).  <a href="group__BasicTypes.html#g64211cf47ad8b6d7d57960e40ea8de67"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef signed short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicTypes.html#g3767da88f86d155ea4a37f01a47a2973">S16</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiler independent signed 16-bit short integer.  <a href="group__BasicTypes.html#g3767da88f86d155ea4a37f01a47a2973"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicTypes.html#g52545eb26974f58fe9d5cd050a9ff61d">U16</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiler independent unsigned 16-bit short integer.  <a href="group__BasicTypes.html#g52545eb26974f58fe9d5cd050a9ff61d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef signed int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38">S32</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiler independent signed 32-bit integer.  <a href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiler independent unsigned 32-bit integer.  <a href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiler independent 32-bit float.  <a href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicTypes.html#ga099c73705161911bb8aba873dc3b554">F64</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compiler independent 64-bit float.  <a href="group__BasicTypes.html#ga099c73705161911bb8aba873dc3b554"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef const <a class="el" href="structTNL_1_1IPAddress.html">IPAddress</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#0dc381114244d16de5ed7fb1ccc2f3fc">IPAddressRef</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef int(QSORT_CALLBACK *)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#cdfb6f7aaae9eac6434ce242716631d5">qsort_compare_func</a> (const void *, const void *)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#161b6874b7f1703b7a179879a2fcee9b">NetClassType</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#161b6874b7f1703b7a179879a2fcee9b68dcfa091d005ea0493f54faf49d346b">NetClassTypeNone</a> =  -1, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#161b6874b7f1703b7a179879a2fcee9b0ec1e325d21aa1dde0996f2a15763d81">NetClassTypeObject</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#161b6874b7f1703b7a179879a2fcee9b9fca9b36f67eb382e8296b70311bfb67">NetClassTypeDataBlock</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#161b6874b7f1703b7a179879a2fcee9b1b63be15035a50487e62ca0cabd39afa">NetClassTypeEvent</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#161b6874b7f1703b7a179879a2fcee9bc1844d861d6eb7049690b511a5581490">NetClassTypeCount</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NetClassTypes are used to define the ranges of individual class identifiers, in order to reduce the number of bits necessary to identify the class of an object across the network.  <a href="namespaceTNL.html#161b6874b7f1703b7a179879a2fcee9b">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#ccf8108c5bf7b82ea474a1a9bebedf33">NetClassGroup</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#ccf8108c5bf7b82ea474a1a9bebedf33009835f2ebf1684483170df914711b56">NetClassGroupGame</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#ccf8108c5bf7b82ea474a1a9bebedf33c7b6f4e1e44aaf73ff0fcbc64b957c27">NetClassGroupCommunity</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#ccf8108c5bf7b82ea474a1a9bebedf3303056fb8ce8e696704698033e5c781fd">NetClassGroupMaster</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#ccf8108c5bf7b82ea474a1a9bebedf33ea2023317471491c170f26ed770cf174">NetClassGroupUnused2</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#ccf8108c5bf7b82ea474a1a9bebedf335331f0347d19ac0eb1227f654b0d5fab">NetClassGroupCount</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#ccf8108c5bf7b82ea474a1a9bebedf33fd6efbdf3c6191c6897a44feee0d26a3">NetClassGroupInvalid</a> =  NetClassGroupCount
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">NetClassGroups are used to define different service types for an application.  <a href="namespaceTNL.html#ccf8108c5bf7b82ea474a1a9bebedf33">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#ee29fe14a63e9c2bd991b0946d3f55b1">NetClassMask</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#ee29fe14a63e9c2bd991b0946d3f55b134df23dd8777ceb10d8203faa5fb3696">NetClassGroupGameMask</a> =  1 &lt;&lt; NetClassGroupGame, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#ee29fe14a63e9c2bd991b0946d3f55b1a0e821ee61a4dd5a92fc15bb5ec4a540">NetClassGroupCommunityMask</a> =  1 &lt;&lt; NetClassGroupCommunity, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#ee29fe14a63e9c2bd991b0946d3f55b11a879029f541e2e0cc0874e1bd56c455">NetClassGroupMasterMask</a> =  1 &lt;&lt; NetClassGroupMaster, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#ee29fe14a63e9c2bd991b0946d3f55b14d680c63b982ddc25145297f43bbc8e9">NetClassGroupAllMask</a> =  (1 &lt;&lt; NetClassGroupCount) - 1
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Mask values used to indicate which NetClassGroup(s) a NetObject or NetEvent can be transmitted through.  <a href="namespaceTNL.html#ee29fe14a63e9c2bd991b0946d3f55b1">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#f46d1dee7473b564429243056c9fa969">NetObjectRPCDirection</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#f46d1dee7473b564429243056c9fa969c0757909d653370e8932696584319518">RPCToGhost</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#f46d1dee7473b564429243056c9fa969bcb2794710a76f4146df71cc20578bbd">RPCToGhostParent</a> =  2
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direction that a NetObject RPC method call should travel.  <a href="namespaceTNL.html#f46d1dee7473b564429243056c9fa969">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#a5742b17dcaf1a95f7226c0cd7681f8f">RPCDirection</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#a5742b17dcaf1a95f7226c0cd7681f8f3ecbdae5fef9d3182349f1d32e242c89">RPCDirAny</a> =  NetEvent::DirAny, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#a5742b17dcaf1a95f7226c0cd7681f8f3da9c56941d82f82cef39ff7ebbc7813">RPCDirServerToClient</a> =  NetEvent::DirServerToClient, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#a5742b17dcaf1a95f7226c0cd7681f8f0ddc0f057995eba33fc334c18a1a0be3">RPCDirClientToServer</a> =  NetEvent::DirClientToServer
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration for valid directions that RPC messages can travel.  <a href="namespaceTNL.html#a5742b17dcaf1a95f7226c0cd7681f8f">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#be624d06822816c58aa7f5c98630608f">RPCGuaranteeType</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#be624d06822816c58aa7f5c98630608f939a6b24cd6978b2e96038df63f58a18">RPCGuaranteedOrdered</a> =  NetEvent::GuaranteedOrdered, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#be624d06822816c58aa7f5c98630608f7e038b3d8de996cb7d48ff099628f2aa">RPCGuaranteed</a> =  NetEvent::Guaranteed, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#be624d06822816c58aa7f5c98630608fe0143f1617fb8dba4077733340228008">RPCUnguaranteed</a> =  NetEvent::Unguaranteed
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Type of data guarantee this RPC should use.  <a href="namespaceTNL.html#be624d06822816c58aa7f5c98630608f">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#e12114fee60117eade7646e528d64113">TransportProtocol</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#e12114fee60117eade7646e528d641134e9520c7208d0dcb0c42a2335a852fa0">IPProtocol</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#e12114fee60117eade7646e528d641133f69c5cf929130dd8258f379fcd1e780">TCPProtocol</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#e12114fee60117eade7646e528d641139f29e7d7f0b65d46a55f8851d2dcf3f3">IPXProtocol</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#e12114fee60117eade7646e528d6411366e9cdd9e443f61244ae33f1b714498d">IPv6Protocol</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enumeration for transport protocols for the <a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a>.  <a href="namespaceTNL.html#e12114fee60117eade7646e528d64113">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#7ea689e7d2177630021c6b84a78103da">Constants</a> { <a class="el" href="namespaceTNL.html#7ea689e7d2177630021c6b84a78103dae10d8c6b80cc4171c7cb252f397a75f4">MaxPacketDataSize</a> =  1500
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Packet level network constants.  <a href="namespaceTNL.html#7ea689e7d2177630021c6b84a78103da">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#e9ba328d3c06917b0161893d7dec74b1">NetError</a> { <br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#e9ba328d3c06917b0161893d7dec74b17c895ab32443b1bc75e29e0ef596a793">NoError</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#e9ba328d3c06917b0161893d7dec74b18e3e47f8b90158d7310b6d3dc0db40e0">InvalidPacketProtocol</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#e9ba328d3c06917b0161893d7dec74b1e673e65122e020f8de78adf9168f4c9c">WouldBlock</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="namespaceTNL.html#e9ba328d3c06917b0161893d7dec74b11f817f3547445899131582b28b8e394d">UnknownError</a>
<br>
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Error conditions that can be returned by sendto and recvfrom.  <a href="namespaceTNL.html#e9ba328d3c06917b0161893d7dec74b1">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#412b2a7fc75acf8ca0419442a004f1cf">avar</a> (const char *in_msg,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">sprintf style string formating into a fixed temporary buffer.  <a href="#412b2a7fc75acf8ca0419442a004f1cf"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g64211cf47ad8b6d7d57960e40ea8de67">U8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#4e77cf3b61941b8f8b2f4bd3d8f9753b">endianSwap</a> (const <a class="el" href="group__BasicTypes.html#g64211cf47ad8b6d7d57960e40ea8de67">U8</a> in_swap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#ge6994d04641f3d1fdbe7a22724117c74">S8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#2501c371807fe2d3c82a9f0a3698d594">endianSwap</a> (const <a class="el" href="group__BasicTypes.html#ge6994d04641f3d1fdbe7a22724117c74">S8</a> in_swap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g52545eb26974f58fe9d5cd050a9ff61d">U16</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#3cfafa9680aa53b70fe4bdfe66a55bed">endianSwap</a> (const <a class="el" href="group__BasicTypes.html#g52545eb26974f58fe9d5cd050a9ff61d">U16</a> in_swap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the byte ordering on the U16 to and from big/little endian format.  <a href="#3cfafa9680aa53b70fe4bdfe66a55bed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g3767da88f86d155ea4a37f01a47a2973">S16</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#7bb5faec8464bb497968e995c83146ef">endianSwap</a> (const <a class="el" href="group__BasicTypes.html#g3767da88f86d155ea4a37f01a47a2973">S16</a> in_swap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#a4ebd6cebbeaf9706e29d34f05e27a74">endianSwap</a> (const <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> in_swap)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Convert the byte ordering on the U32 to and from big/little endian format.  <a href="#a4ebd6cebbeaf9706e29d34f05e27a74"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38">S32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#65c7882aaa7e7ffc06df5e8843bdd87f">endianSwap</a> (const <a class="el" href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38">S32</a> in_swap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">U64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#9fc8fd4f0d953ff5259473360bbec519">endianSwap</a> (const U64 in_swap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">S64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#86afab62476239a4bbfa32a7bc87d53e">endianSwap</a> (const S64 in_swap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#350a764c1bf503f83507fedc8d4d19ff">endianSwap</a> (const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a> in_swap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#ga099c73705161911bb8aba873dc3b554">F64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#5e9b9957f37dba6eeec0d8e6c3b18b78">endianSwap</a> (const <a class="el" href="group__BasicTypes.html#ga099c73705161911bb8aba873dc3b554">F64</a> in_swap)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#753dfaae40cfc4e7b73cd24de7b9ada5">logprintf</a> (const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Global interface to the <a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a> logging system.  <a href="#753dfaae40cfc4e7b73cd24de7b9ada5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#ec79fcbff0cd039f976d30d794aed4ee">atob</a> (const char *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">String to boolean conversion.  <a href="#ec79fcbff0cd039f976d30d794aed4ee"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#f50ead6c007bd461638e549980ba0219">dSprintf</a> (char *buffer, <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> bufferSize, const char *format,...)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Printf into string with a buffer size.  <a href="#f50ead6c007bd461638e549980ba0219"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#dc06f96ef105a02a2268737f65227ce7">dVsprintf</a> (char *buffer, <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> bufferSize, const char *format, void *arglist)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vsprintf with buffer size argument. compiler independent.  <a href="#dc06f96ef105a02a2268737f65227ce7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#ab7f5ca1443bb3d8d5d6d416c02d4b79">dToupper</a> (const char c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an ASCII character to upper case.  <a href="#ab7f5ca1443bb3d8d5d6d416c02d4b79"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#141939792173b56606bb6f29049ade43">dTolower</a> (const char c)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts an ASCII character to lower case.  <a href="#141939792173b56606bb6f29049ade43"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ObjTrickery.html#g65b7c9024d2d874687f7a03df3b9eb79">constructInPlace</a> (T *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs an object that already has memory allocated for it.  <a href="group__ObjTrickery.html#g65b7c9024d2d874687f7a03df3b9eb79"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ObjTrickery.html#gfb9afcc9df06df6e19039130151344c7">constructInPlace</a> (T *p, const T *copy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructs an object that already has memory allocated for it.  <a href="group__ObjTrickery.html#gfb9afcc9df06df6e19039130151344c7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__ObjTrickery.html#gc3d672bb91050a62c09a705b69409ec2">destructInPlace</a> (T *p)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructs an object without freeing the memory associated with it.  <a href="group__ObjTrickery.html#gc3d672bb91050a62c09a705b69409ec2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MinMaxFuncs.html#g274a91cbad82b540da43a5541218c53c">DeclareTemplatizedMinMax</a> (<a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>) DeclareTemplatizedMinMax(<a class="el" href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38">S32</a>) DeclareTemplatizedMinMax(<a class="el" href="group__BasicTypes.html#g52545eb26974f58fe9d5cd050a9ff61d">U16</a>) DeclareTemplatizedMinMax(<a class="el" href="group__BasicTypes.html#g3767da88f86d155ea4a37f01a47a2973">S16</a>) DeclareTemplatizedMinMax(<a class="el" href="group__BasicTypes.html#g64211cf47ad8b6d7d57960e40ea8de67">U8</a>) DeclareTemplatizedMinMax(<a class="el" href="group__BasicTypes.html#ge6994d04641f3d1fdbe7a22724117c74">S8</a>) DeclareTemplatizedMinMax(<a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>) DeclareTemplatizedMinMax(<a class="el" href="group__BasicTypes.html#ga099c73705161911bb8aba873dc3b554">F64</a>) inline void writeU32ToBuffer(<a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> value</td></tr>

<tr><td colspan="2"><div class="groupHeader">GeneralMath Math Helpers</div></td></tr>
<tr><td colspan="2"><div class="groupText">Some general numeric utility functions. <br><br></div></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MinMaxFuncs.html#ga66b26a4b5884ca7ab6be7c88a66db6f">isPow2</a> (const <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if number is a power of two.  <a href="group__MinMaxFuncs.html#ga66b26a4b5884ca7ab6be7c88a66db6f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MinMaxFuncs.html#gdab600150a594096d9dabaa2cf83c8a3">getBinLog2</a> (<a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the binary logarithm of the input value rounded down to the nearest power of 2.  <a href="group__MinMaxFuncs.html#gdab600150a594096d9dabaa2cf83c8a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MinMaxFuncs.html#g3b06a17fae8310798295f4a88a71907d">getNextBinLog2</a> (<a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> number)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the binary logarithm of the next greater power of two of the input number.  <a href="group__MinMaxFuncs.html#g3b06a17fae8310798295f4a88a71907d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__MinMaxFuncs.html#g6d8dc1ec0760915f71b14a401074bf0a">getNextPow2</a> (<a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> value)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the next greater power of two from the value. If the value is a power of two, it is returned.  <a href="group__MinMaxFuncs.html#g6d8dc1ec0760915f71b14a401074bf0a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceTNL.html#66798c0387ba580167ebccef8e9bdd4c">MinimumPaddingBits</a> = 128</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Padding space that is required at the end of each packet for bit flag writes and such.  <a href="#66798c0387ba580167ebccef8e9bdd4c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#gc6a01d5cfe7c9deacc81c46b8f0cf2eb">FloatOne</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(1.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant float 1.0.  <a href="group__BasicConstants.html#gc6a01d5cfe7c9deacc81c46b8f0cf2eb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#gf0ad1f1d710efaabd46a8d305ad12ad7">FloatHalf</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(0.5)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant float 0.5.  <a href="group__BasicConstants.html#gf0ad1f1d710efaabd46a8d305ad12ad7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g0e7432fc2bb4b491b69acec994c7c100">FloatZero</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(0.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant float 0.0.  <a href="group__BasicConstants.html#g0e7432fc2bb4b491b69acec994c7c100"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g53043aee238c473e327fbe41d0ffad80">FloatPi</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(3.14159265358979323846)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant float PI.  <a href="group__BasicConstants.html#g53043aee238c473e327fbe41d0ffad80"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#gd7a750e1d4defa7523ebcea21b9d3269">Float2Pi</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(2.0 * 3.14159265358979323846)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant float 2*PI.  <a href="group__BasicConstants.html#gd7a750e1d4defa7523ebcea21b9d3269"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g058cb16266fc5a9c9f1a7324025d8ca1">FloatInversePi</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(1.0 / 3.14159265358979323846)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant float 1 / PI.  <a href="group__BasicConstants.html#g058cb16266fc5a9c9f1a7324025d8ca1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#gaf5b6dbc5d9ffca548a4ffe0fb65ea14">FloatHalfPi</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(0.5 * 3.14159265358979323846)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant float 1/2 * PI.  <a href="group__BasicConstants.html#gaf5b6dbc5d9ffca548a4ffe0fb65ea14"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g075edd0ae424af0a6ca14b2017ee323c">Float2InversePi</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(2.0 / 3.14159265358979323846)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant float 2 / PI.  <a href="group__BasicConstants.html#g075edd0ae424af0a6ca14b2017ee323c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g1b4e21fab7d9c6a37f9fdaa8f678f248">FloatInverse2Pi</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(0.5 / 3.14159265358979323846)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant float 2 / PI.  <a href="group__BasicConstants.html#g1b4e21fab7d9c6a37f9fdaa8f678f248"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#gc2db4fdf4e2f8c26fba45b144a157c10">FloatSqrt2</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(1.41421356237309504880f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant float sqrt(2).  <a href="group__BasicConstants.html#gc2db4fdf4e2f8c26fba45b144a157c10"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g24d80b3c2a8f69fb7128ffd7d2692c18">FloatSqrtHalf</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(0.7071067811865475244008443f)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant float sqrt(0.5).  <a href="group__BasicConstants.html#g24d80b3c2a8f69fb7128ffd7d2692c18"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#ge6994d04641f3d1fdbe7a22724117c74">S8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g08cf91f9fc686dd961ad79d3785a2bd1">S8_MIN</a> = <a class="el" href="group__BasicTypes.html#ge6994d04641f3d1fdbe7a22724117c74">S8</a>(-128)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Min Limit S8.  <a href="group__BasicConstants.html#g08cf91f9fc686dd961ad79d3785a2bd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#ge6994d04641f3d1fdbe7a22724117c74">S8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#gf8fd7e1e6e4a8b40e2cdc0bcd011f54e">S8_MAX</a> = <a class="el" href="group__BasicTypes.html#ge6994d04641f3d1fdbe7a22724117c74">S8</a>(127)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Max Limit S8.  <a href="group__BasicConstants.html#gf8fd7e1e6e4a8b40e2cdc0bcd011f54e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g64211cf47ad8b6d7d57960e40ea8de67">U8</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g23dae2c216768bad3b14e6c6ebe8d51f">U8_MAX</a> = <a class="el" href="group__BasicTypes.html#g64211cf47ad8b6d7d57960e40ea8de67">U8</a>(255)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Max Limit U8.  <a href="group__BasicConstants.html#g23dae2c216768bad3b14e6c6ebe8d51f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g3767da88f86d155ea4a37f01a47a2973">S16</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#ga4c45f02215c26a158b50ee02b1d9db7">S16_MIN</a> = <a class="el" href="group__BasicTypes.html#g3767da88f86d155ea4a37f01a47a2973">S16</a>(-32768)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Min Limit S16.  <a href="group__BasicConstants.html#ga4c45f02215c26a158b50ee02b1d9db7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g3767da88f86d155ea4a37f01a47a2973">S16</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g76e08317f77133959b58d0fba13deb98">S16_MAX</a> = <a class="el" href="group__BasicTypes.html#g3767da88f86d155ea4a37f01a47a2973">S16</a>(32767)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Max Limit S16.  <a href="group__BasicConstants.html#g76e08317f77133959b58d0fba13deb98"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g52545eb26974f58fe9d5cd050a9ff61d">U16</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g58fbaa1ff78809d38e56b2702a784edb">U16_MAX</a> = <a class="el" href="group__BasicTypes.html#g52545eb26974f58fe9d5cd050a9ff61d">U16</a>(65535)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Max Limit U16.  <a href="group__BasicConstants.html#g58fbaa1ff78809d38e56b2702a784edb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38">S32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#gb424e4072fc47e7a43c30e384a2849a2">S32_MIN</a> = <a class="el" href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38">S32</a>(-2147483647 - 1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Min Limit S32.  <a href="group__BasicConstants.html#gb424e4072fc47e7a43c30e384a2849a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38">S32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g861f81ebc190b7b87ceb0b820516451a">S32_MAX</a> = <a class="el" href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38">S32</a>(2147483647)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Max Limit S32.  <a href="group__BasicConstants.html#g861f81ebc190b7b87ceb0b820516451a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#g5606802911f86e93267dcf59c9b9c267">U32_MAX</a> = <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a>(0xffffffff)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Max Limit U32.  <a href="group__BasicConstants.html#g5606802911f86e93267dcf59c9b9c267"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#gf26c8c0cfaba2a44a49ebdecc391d644">F32_MIN</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(1.175494351e-38F)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Min Limit F32.  <a href="group__BasicConstants.html#gf26c8c0cfaba2a44a49ebdecc391d644"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__BasicConstants.html#gd63b44cc8c1e8583e92055ef492ba6c1">F32_MAX</a> = <a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a>(3.402823466e+38F)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constant Max Limit F32.  <a href="group__BasicConstants.html#gd63b44cc8c1e8583e92055ef492ba6c1"></a><br></td></tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="be6c1cf7e7d16e13ca09ee2aa7e43ea6"></a><!-- doxytag: member="TNL::AsymmetricKeyPtr" ref="be6c1cf7e7d16e13ca09ee2aa7e43ea6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTNL_1_1RefPtr.html">RefPtr</a>&lt;<a class="el" href="classTNL_1_1AsymmetricKey.html">AsymmetricKey</a>&gt; <a class="el" href="classTNL_1_1RefPtr.html">TNL::AsymmetricKeyPtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="e6144f462fa5173cd86fcb1f181a6640"></a><!-- doxytag: member="TNL::ByteBufferPtr" ref="e6144f462fa5173cd86fcb1f181a6640" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classTNL_1_1RefPtr.html">RefPtr</a>&lt;<a class="el" href="classTNL_1_1ByteBuffer.html">ByteBuffer</a>&gt; <a class="el" href="classTNL_1_1RefPtr.html">TNL::ByteBufferPtr</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="fd83cd07117d7fceea78779feb72fcec"></a><!-- doxytag: member="TNL::ByteBufferRef" ref="fd83cd07117d7fceea78779feb72fcec" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classTNL_1_1ByteBuffer.html">ByteBuffer</a>&amp; <a class="el" href="classTNL_1_1ByteBuffer.html">TNL::ByteBufferRef</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="652eaee5cff7a9386d961dea6ed03b99"></a><!-- doxytag: member="TNL::StringTableEntryId" ref="652eaee5cff7a9386d961dea6ed03b99" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> <a class="el" href="namespaceTNL.html#652eaee5cff7a9386d961dea6ed03b99">TNL::StringTableEntryId</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="d08d8c0b3cd49c84a970ecee83927089"></a><!-- doxytag: member="TNL::StringTableEntryRef" ref="d08d8c0b3cd49c84a970ecee83927089" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classTNL_1_1StringTableEntry.html">StringTableEntry</a>&amp; <a class="el" href="classTNL_1_1StringTableEntry.html">TNL::StringTableEntryRef</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="0dc381114244d16de5ed7fb1ccc2f3fc"></a><!-- doxytag: member="TNL::IPAddressRef" ref="0dc381114244d16de5ed7fb1ccc2f3fc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="structTNL_1_1IPAddress.html">IPAddress</a>&amp; <a class="el" href="structTNL_1_1IPAddress.html">TNL::IPAddressRef</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="cdfb6f7aaae9eac6434ce242716631d5"></a><!-- doxytag: member="TNL::qsort_compare_func" ref="cdfb6f7aaae9eac6434ce242716631d5" args="(const void *, const void *)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(QSORT_CALLBACK *) <a class="el" href="namespaceTNL.html#cdfb6f7aaae9eac6434ce242716631d5">TNL::qsort_compare_func</a>(const void *, const void *)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="161b6874b7f1703b7a179879a2fcee9b"></a><!-- doxytag: member="TNL::NetClassType" ref="161b6874b7f1703b7a179879a2fcee9b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceTNL.html#161b6874b7f1703b7a179879a2fcee9b">TNL::NetClassType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
NetClassTypes are used to define the ranges of individual class identifiers, in order to reduce the number of bits necessary to identify the class of an object across the network. 
<p>
For example, if there are only 21 classes declared of NetClassTypeObject, the class identifier only needs to be sent using 5 bits. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="161b6874b7f1703b7a179879a2fcee9b68dcfa091d005ea0493f54faf49d346b"></a><!-- doxytag: member="NetClassTypeNone" ref="161b6874b7f1703b7a179879a2fcee9b68dcfa091d005ea0493f54faf49d346b" args="" -->NetClassTypeNone</em>&nbsp;</td><td>
Not an id'able network class. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="161b6874b7f1703b7a179879a2fcee9b0ec1e325d21aa1dde0996f2a15763d81"></a><!-- doxytag: member="NetClassTypeObject" ref="161b6874b7f1703b7a179879a2fcee9b0ec1e325d21aa1dde0996f2a15763d81" args="" -->NetClassTypeObject</em>&nbsp;</td><td>
Game object classes. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="161b6874b7f1703b7a179879a2fcee9b9fca9b36f67eb382e8296b70311bfb67"></a><!-- doxytag: member="NetClassTypeDataBlock" ref="161b6874b7f1703b7a179879a2fcee9b9fca9b36f67eb382e8296b70311bfb67" args="" -->NetClassTypeDataBlock</em>&nbsp;</td><td>
Data block classes. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="161b6874b7f1703b7a179879a2fcee9b1b63be15035a50487e62ca0cabd39afa"></a><!-- doxytag: member="NetClassTypeEvent" ref="161b6874b7f1703b7a179879a2fcee9b1b63be15035a50487e62ca0cabd39afa" args="" -->NetClassTypeEvent</em>&nbsp;</td><td>
Event classes. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="161b6874b7f1703b7a179879a2fcee9bc1844d861d6eb7049690b511a5581490"></a><!-- doxytag: member="NetClassTypeCount" ref="161b6874b7f1703b7a179879a2fcee9bc1844d861d6eb7049690b511a5581490" args="" -->NetClassTypeCount</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="ccf8108c5bf7b82ea474a1a9bebedf33"></a><!-- doxytag: member="TNL::NetClassGroup" ref="ccf8108c5bf7b82ea474a1a9bebedf33" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceTNL.html#ccf8108c5bf7b82ea474a1a9bebedf33">TNL::NetClassGroup</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
NetClassGroups are used to define different service types for an application. 
<p>
Each network-related class can be marked as valid across one or more NetClassGroups. Each network connection belongs to a particular group, and can only transmit objects that are valid in that group. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ccf8108c5bf7b82ea474a1a9bebedf33009835f2ebf1684483170df914711b56"></a><!-- doxytag: member="NetClassGroupGame" ref="ccf8108c5bf7b82ea474a1a9bebedf33009835f2ebf1684483170df914711b56" args="" -->NetClassGroupGame</em>&nbsp;</td><td>
Group for game related network classes. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ccf8108c5bf7b82ea474a1a9bebedf33c7b6f4e1e44aaf73ff0fcbc64b957c27"></a><!-- doxytag: member="NetClassGroupCommunity" ref="ccf8108c5bf7b82ea474a1a9bebedf33c7b6f4e1e44aaf73ff0fcbc64b957c27" args="" -->NetClassGroupCommunity</em>&nbsp;</td><td>
Group for community server/authentication classes. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ccf8108c5bf7b82ea474a1a9bebedf3303056fb8ce8e696704698033e5c781fd"></a><!-- doxytag: member="NetClassGroupMaster" ref="ccf8108c5bf7b82ea474a1a9bebedf3303056fb8ce8e696704698033e5c781fd" args="" -->NetClassGroupMaster</em>&nbsp;</td><td>
Group for simple master server. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ccf8108c5bf7b82ea474a1a9bebedf33ea2023317471491c170f26ed770cf174"></a><!-- doxytag: member="NetClassGroupUnused2" ref="ccf8108c5bf7b82ea474a1a9bebedf33ea2023317471491c170f26ed770cf174" args="" -->NetClassGroupUnused2</em>&nbsp;</td><td>
Reserved group. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ccf8108c5bf7b82ea474a1a9bebedf335331f0347d19ac0eb1227f654b0d5fab"></a><!-- doxytag: member="NetClassGroupCount" ref="ccf8108c5bf7b82ea474a1a9bebedf335331f0347d19ac0eb1227f654b0d5fab" args="" -->NetClassGroupCount</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ccf8108c5bf7b82ea474a1a9bebedf33fd6efbdf3c6191c6897a44feee0d26a3"></a><!-- doxytag: member="NetClassGroupInvalid" ref="ccf8108c5bf7b82ea474a1a9bebedf33fd6efbdf3c6191c6897a44feee0d26a3" args="" -->NetClassGroupInvalid</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="ee29fe14a63e9c2bd991b0946d3f55b1"></a><!-- doxytag: member="TNL::NetClassMask" ref="ee29fe14a63e9c2bd991b0946d3f55b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceTNL.html#ee29fe14a63e9c2bd991b0946d3f55b1">TNL::NetClassMask</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask values used to indicate which NetClassGroup(s) a <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> or <a class="el" href="classTNL_1_1NetEvent.html" title="An event to be sent over the network.">NetEvent</a> can be transmitted through. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ee29fe14a63e9c2bd991b0946d3f55b134df23dd8777ceb10d8203faa5fb3696"></a><!-- doxytag: member="NetClassGroupGameMask" ref="ee29fe14a63e9c2bd991b0946d3f55b134df23dd8777ceb10d8203faa5fb3696" args="" -->NetClassGroupGameMask</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ee29fe14a63e9c2bd991b0946d3f55b1a0e821ee61a4dd5a92fc15bb5ec4a540"></a><!-- doxytag: member="NetClassGroupCommunityMask" ref="ee29fe14a63e9c2bd991b0946d3f55b1a0e821ee61a4dd5a92fc15bb5ec4a540" args="" -->NetClassGroupCommunityMask</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ee29fe14a63e9c2bd991b0946d3f55b11a879029f541e2e0cc0874e1bd56c455"></a><!-- doxytag: member="NetClassGroupMasterMask" ref="ee29fe14a63e9c2bd991b0946d3f55b11a879029f541e2e0cc0874e1bd56c455" args="" -->NetClassGroupMasterMask</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="ee29fe14a63e9c2bd991b0946d3f55b14d680c63b982ddc25145297f43bbc8e9"></a><!-- doxytag: member="NetClassGroupAllMask" ref="ee29fe14a63e9c2bd991b0946d3f55b14d680c63b982ddc25145297f43bbc8e9" args="" -->NetClassGroupAllMask</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="f46d1dee7473b564429243056c9fa969"></a><!-- doxytag: member="TNL::NetObjectRPCDirection" ref="f46d1dee7473b564429243056c9fa969" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceTNL.html#f46d1dee7473b564429243056c9fa969">TNL::NetObjectRPCDirection</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Direction that a <a class="el" href="classTNL_1_1NetObject.html" title="Superclass for ghostable networked objects.">NetObject</a> RPC method call should travel. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="f46d1dee7473b564429243056c9fa969c0757909d653370e8932696584319518"></a><!-- doxytag: member="RPCToGhost" ref="f46d1dee7473b564429243056c9fa969c0757909d653370e8932696584319518" args="" -->RPCToGhost</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" name="f46d1dee7473b564429243056c9fa969bcb2794710a76f4146df71cc20578bbd"></a><!-- doxytag: member="RPCToGhostParent" ref="f46d1dee7473b564429243056c9fa969bcb2794710a76f4146df71cc20578bbd" args="" -->RPCToGhostParent</em>&nbsp;</td><td>
</td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="a5742b17dcaf1a95f7226c0cd7681f8f"></a><!-- doxytag: member="TNL::RPCDirection" ref="a5742b17dcaf1a95f7226c0cd7681f8f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceTNL.html#a5742b17dcaf1a95f7226c0cd7681f8f">TNL::RPCDirection</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration for valid directions that RPC messages can travel. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="a5742b17dcaf1a95f7226c0cd7681f8f3ecbdae5fef9d3182349f1d32e242c89"></a><!-- doxytag: member="RPCDirAny" ref="a5742b17dcaf1a95f7226c0cd7681f8f3ecbdae5fef9d3182349f1d32e242c89" args="" -->RPCDirAny</em>&nbsp;</td><td>
This RPC can be sent from the server or the client. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a5742b17dcaf1a95f7226c0cd7681f8f3da9c56941d82f82cef39ff7ebbc7813"></a><!-- doxytag: member="RPCDirServerToClient" ref="a5742b17dcaf1a95f7226c0cd7681f8f3da9c56941d82f82cef39ff7ebbc7813" args="" -->RPCDirServerToClient</em>&nbsp;</td><td>
This RPC can only be sent from the server to the client. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a5742b17dcaf1a95f7226c0cd7681f8f0ddc0f057995eba33fc334c18a1a0be3"></a><!-- doxytag: member="RPCDirClientToServer" ref="a5742b17dcaf1a95f7226c0cd7681f8f0ddc0f057995eba33fc334c18a1a0be3" args="" -->RPCDirClientToServer</em>&nbsp;</td><td>
This RPC can only be sent from the client to the server. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="be624d06822816c58aa7f5c98630608f"></a><!-- doxytag: member="TNL::RPCGuaranteeType" ref="be624d06822816c58aa7f5c98630608f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceTNL.html#be624d06822816c58aa7f5c98630608f">TNL::RPCGuaranteeType</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Type of data guarantee this RPC should use. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="be624d06822816c58aa7f5c98630608f939a6b24cd6978b2e96038df63f58a18"></a><!-- doxytag: member="RPCGuaranteedOrdered" ref="be624d06822816c58aa7f5c98630608f939a6b24cd6978b2e96038df63f58a18" args="" -->RPCGuaranteedOrdered</em>&nbsp;</td><td>
RPC event delivery is guaranteed and will be processed in the order it was sent relative to other ordered events and RPCs. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="be624d06822816c58aa7f5c98630608f7e038b3d8de996cb7d48ff099628f2aa"></a><!-- doxytag: member="RPCGuaranteed" ref="be624d06822816c58aa7f5c98630608f7e038b3d8de996cb7d48ff099628f2aa" args="" -->RPCGuaranteed</em>&nbsp;</td><td>
RPC event delivery is guaranteed and will be processed in the order it was received. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="be624d06822816c58aa7f5c98630608fe0143f1617fb8dba4077733340228008"></a><!-- doxytag: member="RPCUnguaranteed" ref="be624d06822816c58aa7f5c98630608fe0143f1617fb8dba4077733340228008" args="" -->RPCUnguaranteed</em>&nbsp;</td><td>
Event delivery is not guaranteed - however, the event will remain ordered relative to other unguaranteed events. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="e12114fee60117eade7646e528d64113"></a><!-- doxytag: member="TNL::TransportProtocol" ref="e12114fee60117eade7646e528d64113" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceTNL.html#e12114fee60117eade7646e528d64113">TNL::TransportProtocol</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enumeration for transport protocols for the <a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a>. 
<p>
Currently only IP and IPX are supported - the IPv6 constant is for future use. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="e12114fee60117eade7646e528d641134e9520c7208d0dcb0c42a2335a852fa0"></a><!-- doxytag: member="IPProtocol" ref="e12114fee60117eade7646e528d641134e9520c7208d0dcb0c42a2335a852fa0" args="" -->IPProtocol</em>&nbsp;</td><td>
The standard Internet routing protocol. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e12114fee60117eade7646e528d641133f69c5cf929130dd8258f379fcd1e780"></a><!-- doxytag: member="TCPProtocol" ref="e12114fee60117eade7646e528d641133f69c5cf929130dd8258f379fcd1e780" args="" -->TCPProtocol</em>&nbsp;</td><td>
The standard Internet guaranteed delivery protocol. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e12114fee60117eade7646e528d641139f29e7d7f0b65d46a55f8851d2dcf3f3"></a><!-- doxytag: member="IPXProtocol" ref="e12114fee60117eade7646e528d641139f29e7d7f0b65d46a55f8851d2dcf3f3" args="" -->IPXProtocol</em>&nbsp;</td><td>
Novell's IPX protocol. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e12114fee60117eade7646e528d6411366e9cdd9e443f61244ae33f1b714498d"></a><!-- doxytag: member="IPv6Protocol" ref="e12114fee60117eade7646e528d6411366e9cdd9e443f61244ae33f1b714498d" args="" -->IPv6Protocol</em>&nbsp;</td><td>
The next generation 128-bit address internet protocol (not currently supported by <a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a>). </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="7ea689e7d2177630021c6b84a78103da"></a><!-- doxytag: member="TNL::Constants" ref="7ea689e7d2177630021c6b84a78103da" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceTNL.html#7ea689e7d2177630021c6b84a78103da">TNL::Constants</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Packet level network constants. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="7ea689e7d2177630021c6b84a78103dae10d8c6b80cc4171c7cb252f397a75f4"></a><!-- doxytag: member="MaxPacketDataSize" ref="7ea689e7d2177630021c6b84a78103dae10d8c6b80cc4171c7cb252f397a75f4" args="" -->MaxPacketDataSize</em>&nbsp;</td><td>
The maximum size of a data packet sent through the Net::sendto and Net::recvfrom functions. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="e9ba328d3c06917b0161893d7dec74b1"></a><!-- doxytag: member="TNL::NetError" ref="e9ba328d3c06917b0161893d7dec74b1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceTNL.html#e9ba328d3c06917b0161893d7dec74b1">TNL::NetError</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Error conditions that can be returned by sendto and recvfrom. 
<p>
<dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="e9ba328d3c06917b0161893d7dec74b17c895ab32443b1bc75e29e0ef596a793"></a><!-- doxytag: member="NoError" ref="e9ba328d3c06917b0161893d7dec74b17c895ab32443b1bc75e29e0ef596a793" args="" -->NoError</em>&nbsp;</td><td>
The operation succeeded without error. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e9ba328d3c06917b0161893d7dec74b18e3e47f8b90158d7310b6d3dc0db40e0"></a><!-- doxytag: member="InvalidPacketProtocol" ref="e9ba328d3c06917b0161893d7dec74b18e3e47f8b90158d7310b6d3dc0db40e0" args="" -->InvalidPacketProtocol</em>&nbsp;</td><td>
The program attempted to send a packet to an address using a socket that didn't support the protocol of the address. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e9ba328d3c06917b0161893d7dec74b1e673e65122e020f8de78adf9168f4c9c"></a><!-- doxytag: member="WouldBlock" ref="e9ba328d3c06917b0161893d7dec74b1e673e65122e020f8de78adf9168f4c9c" args="" -->WouldBlock</em>&nbsp;</td><td>
The operation would have blocked, for example if there was no data to read. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="e9ba328d3c06917b0161893d7dec74b11f817f3547445899131582b28b8e394d"></a><!-- doxytag: member="UnknownError" ref="e9ba328d3c06917b0161893d7dec74b11f817f3547445899131582b28b8e394d" args="" -->UnknownError</em>&nbsp;</td><td>
There was some other, unknown error. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="412b2a7fc75acf8ca0419442a004f1cf"></a><!-- doxytag: member="TNL::avar" ref="412b2a7fc75acf8ca0419442a004f1cf" args="(const char *in_msg,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* TNL::avar           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>in_msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
sprintf style string formating into a fixed temporary buffer. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>in_msg</em>&nbsp;</td><td>sprintf style format string </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>pointer to fixed buffer containing formatted string</dd></dl>
<b>Example:</b> <div class="fragment"><pre class="fragment">   <a class="code" href="group__BasicTypes.html#g64211cf47ad8b6d7d57960e40ea8de67" title="Compiler independent unsigned char (8bit integer).">U8</a> a = 5;
   <a class="code" href="group__BasicTypes.html#g3767da88f86d155ea4a37f01a47a2973" title="Compiler independent signed 16-bit short integer.">S16</a> b = -10;
   <span class="keywordtype">char</span> *output = <a class="code" href="namespaceTNL.html#412b2a7fc75acf8ca0419442a004f1cf" title="sprintf style string formating into a fixed temporary buffer.">avar</a>(<span class="stringliteral">"hello %s! a=%u, b=%d"</span>, <span class="stringliteral">"world"</span>);
   ouput = <span class="stringliteral">"hello world! a=5, b=-10"</span>
</pre></div> <dl class="warning" compact><dt><b>Warning:</b></dt><dd>avar uses a static fixed buffer. Treat the buffer as volatile data and use it immediately. Other functions my use avar too and clobber the buffer. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e77cf3b61941b8f8b2f4bd3d8f9753b"></a><!-- doxytag: member="TNL::endianSwap" ref="4e77cf3b61941b8f8b2f4bd3d8f9753b" args="(const U8 in_swap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#g64211cf47ad8b6d7d57960e40ea8de67">U8</a> TNL::endianSwap           </td>
          <td>(</td>
          <td class="paramtype">const U8&nbsp;</td>
          <td class="paramname"> <em>in_swap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="2501c371807fe2d3c82a9f0a3698d594"></a><!-- doxytag: member="TNL::endianSwap" ref="2501c371807fe2d3c82a9f0a3698d594" args="(const S8 in_swap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#ge6994d04641f3d1fdbe7a22724117c74">S8</a> TNL::endianSwap           </td>
          <td>(</td>
          <td class="paramtype">const S8&nbsp;</td>
          <td class="paramname"> <em>in_swap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="3cfafa9680aa53b70fe4bdfe66a55bed"></a><!-- doxytag: member="TNL::endianSwap" ref="3cfafa9680aa53b70fe4bdfe66a55bed" args="(const U16 in_swap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#g52545eb26974f58fe9d5cd050a9ff61d">U16</a> TNL::endianSwap           </td>
          <td>(</td>
          <td class="paramtype">const U16&nbsp;</td>
          <td class="paramname"> <em>in_swap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the byte ordering on the U16 to and from big/little endian format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>in_swap</em>&nbsp;</td><td>Any U16 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>swapped U16. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7bb5faec8464bb497968e995c83146ef"></a><!-- doxytag: member="TNL::endianSwap" ref="7bb5faec8464bb497968e995c83146ef" args="(const S16 in_swap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#g3767da88f86d155ea4a37f01a47a2973">S16</a> TNL::endianSwap           </td>
          <td>(</td>
          <td class="paramtype">const S16&nbsp;</td>
          <td class="paramname"> <em>in_swap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="a4ebd6cebbeaf9706e29d34f05e27a74"></a><!-- doxytag: member="TNL::endianSwap" ref="a4ebd6cebbeaf9706e29d34f05e27a74" args="(const U32 in_swap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> TNL::endianSwap           </td>
          <td>(</td>
          <td class="paramtype">const U32&nbsp;</td>
          <td class="paramname"> <em>in_swap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Convert the byte ordering on the U32 to and from big/little endian format. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>in_swap</em>&nbsp;</td><td>Any U32 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>swapped U32. </dd></dl>

</div>
</div><p>
<a class="anchor" name="65c7882aaa7e7ffc06df5e8843bdd87f"></a><!-- doxytag: member="TNL::endianSwap" ref="65c7882aaa7e7ffc06df5e8843bdd87f" args="(const S32 in_swap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#g370c461a302fda09f1b6ac176c81df38">S32</a> TNL::endianSwap           </td>
          <td>(</td>
          <td class="paramtype">const S32&nbsp;</td>
          <td class="paramname"> <em>in_swap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9fc8fd4f0d953ff5259473360bbec519"></a><!-- doxytag: member="TNL::endianSwap" ref="9fc8fd4f0d953ff5259473360bbec519" args="(const U64 in_swap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U64 TNL::endianSwap           </td>
          <td>(</td>
          <td class="paramtype">const U64&nbsp;</td>
          <td class="paramname"> <em>in_swap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="86afab62476239a4bbfa32a7bc87d53e"></a><!-- doxytag: member="TNL::endianSwap" ref="86afab62476239a4bbfa32a7bc87d53e" args="(const S64 in_swap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">S64 TNL::endianSwap           </td>
          <td>(</td>
          <td class="paramtype">const S64&nbsp;</td>
          <td class="paramname"> <em>in_swap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="350a764c1bf503f83507fedc8d4d19ff"></a><!-- doxytag: member="TNL::endianSwap" ref="350a764c1bf503f83507fedc8d4d19ff" args="(const F32 in_swap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#g48fa67f8c9749318e86d091946441ec5">F32</a> TNL::endianSwap           </td>
          <td>(</td>
          <td class="paramtype">const F32&nbsp;</td>
          <td class="paramname"> <em>in_swap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="5e9b9957f37dba6eeec0d8e6c3b18b78"></a><!-- doxytag: member="TNL::endianSwap" ref="5e9b9957f37dba6eeec0d8e6c3b18b78" args="(const F64 in_swap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__BasicTypes.html#ga099c73705161911bb8aba873dc3b554">F64</a> TNL::endianSwap           </td>
          <td>(</td>
          <td class="paramtype">const F64&nbsp;</td>
          <td class="paramname"> <em>in_swap</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="753dfaae40cfc4e7b73cd24de7b9ada5"></a><!-- doxytag: member="TNL::logprintf" ref="753dfaae40cfc4e7b73cd24de7b9ada5" args="(const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TNL::logprintf           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Global interface to the <a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a> logging system. 
<p>
The <a class="el" href="namespaceTNL.html" title="Global namespace for all TNL classes.">TNL</a> logging system is consumer based. This is just a global stub that routes the log string to all the consumers.<p>
You should <b>really</b> be using the <a class="el" href="tnlLog_8h.html#3f3227d46ea78da0b7f35d9c6b4a5233" title="Logs a message of the specified type to the currently active LogConsumers.">TNLLogMessage()</a> and <a class="el" href="tnlLog_8h.html#b436a8ee09af0ddd2eda62d374282885" title="Logs a printf-style variable argument message of the specified type to the currently...">TNLLogMessageV()</a> macros instead of calling this.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classTNL_1_1LogConsumer.html" title="LogConsumer is the base class for the message logging system in TNL.">LogConsumer</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="ec79fcbff0cd039f976d30d794aed4ee"></a><!-- doxytag: member="TNL::atob" ref="ec79fcbff0cd039f976d30d794aed4ee" args="(const char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TNL::atob           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
String to boolean conversion. 
<p>

</div>
</div><p>
<a class="anchor" name="f50ead6c007bd461638e549980ba0219"></a><!-- doxytag: member="TNL::dSprintf" ref="f50ead6c007bd461638e549980ba0219" args="(char *buffer, U32 bufferSize, const char *format,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TNL::dSprintf           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&nbsp;</td>
          <td class="paramname"> <em>...</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Printf into string with a buffer size. 
<p>
This will print into the specified string until the buffer size is reached. 
</div>
</div><p>
<a class="anchor" name="dc06f96ef105a02a2268737f65227ce7"></a><!-- doxytag: member="TNL::dVsprintf" ref="dc06f96ef105a02a2268737f65227ce7" args="(char *buffer, U32 bufferSize, const char *format, void *arglist)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TNL::dVsprintf           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>bufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>arglist</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Vsprintf with buffer size argument. compiler independent. 
<p>
This will print into the specified string until the buffer size is reached. 
</div>
</div><p>
<a class="anchor" name="ab7f5ca1443bb3d8d5d6d416c02d4b79"></a><!-- doxytag: member="TNL::dToupper" ref="ab7f5ca1443bb3d8d5d6d416c02d4b79" args="(const char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char TNL::dToupper           </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts an ASCII character to upper case. 
<p>

</div>
</div><p>
<a class="anchor" name="141939792173b56606bb6f29049ade43"></a><!-- doxytag: member="TNL::dTolower" ref="141939792173b56606bb6f29049ade43" args="(const char c)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char TNL::dTolower           </td>
          <td>(</td>
          <td class="paramtype">const char&nbsp;</td>
          <td class="paramname"> <em>c</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Converts an ASCII character to lower case. 
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="66798c0387ba580167ebccef8e9bdd4c"></a><!-- doxytag: member="TNL::MinimumPaddingBits" ref="66798c0387ba580167ebccef8e9bdd4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__BasicTypes.html#g451c663f505932ae1f2a02da6e8d20f1">U32</a> <a class="el" href="namespaceTNL.html#66798c0387ba580167ebccef8e9bdd4c">TNL::MinimumPaddingBits</a> = 128<code> [static]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Padding space that is required at the end of each packet for bit flag writes and such. 
<p>

</div>
</div><p>
			<div class="footer">
			Documentation hosted by <a href="http://sourceforge.net/">SourceForge.net</a><br>
			<small><b>All Rights Reserved <A href="http://www.garagegames.com/">GarageGames.com, Inc.</a> 1999-2004</b></small><br>
            <small>Documentation auto-magically Generated with <a href='http://www.doxygen.org' target='_blank'>Doxygen 1.5.2</a></small>
			</div>
		</TD>
	</TR>
</TABLE>
</BODY>
</HTML>
