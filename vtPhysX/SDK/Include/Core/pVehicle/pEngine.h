// racer/engine.h
// 30-12-01: Gearbox split from engine into class RGearBox

#ifndef __P_ENGINE_H__
#define __P_ENGINE_H__

#include "vtPhysXBase.h"
#include "pDriveline.h"
#include "pVehicleTypes.h"


class RWheel;

class MODULE_API pEngine : public pDriveLineComp
{
 public:
  enum Flags
  {
    STALLED=1,                          // Engine is turned off
    HAS_STARTER=2,                      // Start engine present?
    START_STALLED=4,                     // When reset, don't autostart engine?
    AUTOCLUTCH_ACTIVE=8                 // Assist on?
  };

  enum Max
  { MAX_GEAR=10                         // #gears possible
  };

  
  //----------------------------------------------------------------
  //
  // public interface 
  //


  

 public:
  pVehicle    *ownerVehicle;                         // The car to which we belong
  

  // Static data
  float   size;
  VxVector position;
  float   mass;
  
  int      flags;
  
  int& getFlags() { return flags; }
  void setFlags(int val);

  // To calculate engine braking

  float   idleThrottle,                // Always open by this much 0..1
           throttleRange;               // Effective throttle range
  float   maxTorque;                   // Factor for normalize torque curve
  
  float   maxRPM;                      // Hard maximum

  float getMaxTorque() const { return maxTorque; }
  void setMaxTorque(float val) { maxTorque = val; }
  float getMaxRPM() const { return maxRPM; }
  void setMaxRPM(float val) { maxRPM = val; }
  float getClutch() const { return clutch; }
  void setClutch(float val) { clutch = val; }
  
  int getFrictionMethod() { return FC_GENTA ;}
  
  


  float clutch;                         // Clutch 0..1 (1=fully locked)
  
  

  //int    autoShiftStart;                 // Time of auto shift initiation
  //int    futureGear;                     // Gear to shift to
  //float rotationV;                      // Engine rotation speed
  float torqueWheels,                   // Torque available for the wheels
	  torqueEngine;
  //----------------------------------------------------------------
  //
  // customizable attributes
  //
  
  float   starterTorque;               // Torque generated by starter
  float idleRPM;                     // RPM when no throttle/friction
  float forceFeedbackScale;

public :
	
	float getForceFeedbackScale() const { return forceFeedbackScale; }
	void setForceFeedbackScale(float val) { forceFeedbackScale = val; }

  float getStarterTorque() const { return starterTorque; }
  void setStarterTorque(float val);
  float getIdleRPM() const { return idleRPM; }
  void setIdleRPM(float val);
  float getStallRPM() const { return stallRPM; }
  void setStallRPM(float val) { stallRPM = val; }
  
  float getBrakingCoeff() const { return brakingCoeff; }
  void setBrakingCoeff(float val);
  
  float getFriction() const { return friction; }
  void setFriction(float val);
  
  float getStartRPM() const { return startRPM; }
  void setStartRPM(float val);
  
  float getAutoClutchRPM() const { return autoClutchRPM; }
  void setAutoClutchRPM(float val) { autoClutchRPM = val; }

  float stallRPM;                    // At which point does the engine stall
  float startRPM;                    // At which point does it turn on again?
  float autoClutchRPM;               // When to start applying the clutch
  float   friction;                    // Friction coeff of motor itself
  float   brakingCoeff;  
  
  
  //----------------------------------------------------------------
  //
  // unknown 
  //
  
  float   torqueReaction;              // Amount (0..1) at which engine

  // Dynamic data (some (tEngine) is stored in RDriveLineComp)
  
                                        // torque reaches the body
 
  // Physical attributes
  // Inertia
  float  inertiaEngine,                 // Engine internal rotation
          inertiaDriveShaft;             // Differential
  // Gearbox
  float gearRatio[MAX_GEAR];
  int    gears;
  float endRatio;                       // Final drive ratio
  float gearInertia[MAX_GEAR];          // Rotational inertia per gear
  // Shifting
  int    timeToDeclutch,                 // Auto-shifting time
         timeToClutch;
  float shiftUpRPM,                     // Automatic transmissions
         shiftDownRPM;


  // State (dynamic output)
  int    curGear;                        // Selected gear
  float force;                          // Force put out
  float torque;                         // Torque sent to drivetrain
  

  // Input
  float throttle;
  float brakes;

  pLinearInterpolation torqueCurve;
   
 public:
  pEngine(pVehicle *car);
  ~pEngine();

  void setToDefault();
  
  pLinearInterpolation* getTorqueCurve(){ return &torqueCurve; }
  void setTorqueCurve(pLinearInterpolation val);

  pVehicle * getVehicle(){ return ownerVehicle; }
  void getVehicle(pVehicle * val) { ownerVehicle = val; }

  
  float getRPM(){ return (GetRotationVel()/(2*PI))*60.0f; }
  void   setRPM(float rpm);
  float getTorque(){ return GetEngineTorque(); }
  
  

  // Definition

  void clean();                          // clean all vars
  void initData();                           // Initialize usage of engine
  void preStep();                   // Precalculate some variables

  // Attribs
  float GetMass(){ return mass; }
  
  bool   IsStalled(){ if(flags&STALLED)return TRUE; return FALSE; }
  void   EnableStall(){ flags|=STALLED; }
  void   DisableStall(){ flags&=~STALLED; }
  bool   HasStarter(){ if(flags&HAS_STARTER)return TRUE; return FALSE; }


  /*
  bool   IsAutoClutchActive()
  { if(flags&AUTOCLUTCH_ACTIVE)return TRUE; return FALSE; }
  float GetAutoClutch(){ return autoClutch; }
  */


  // Engine torque generation
  float GetMinTorque(float rpm);
  float GetMaxTorque(float rpm);
  float GetTorqueAtDifferential();

  float GetEngineInertia(){ return inertiaEngine; }
  float GetGearInertia(){ return gearInertia[curGear]; }
  float GetInertiaAtDifferential();
  float GetInertiaForWheel(pWheel2 *w);
  float GetTorqueForWheel(pWheel2 *w);


  // Gearbox
  int    GetGears(){ return gears; }
  int    GetGear(){ return curGear; }
  float GetGearRatio(int n);
  float GetEndRatio();
  void   SetGear(int n);


  // Input
  
  void updateUserControl(int ctlThrottle);
  

  // Physics
  void CalcForces();
  void CalcAccelerations();
  
  void Integrate();


  float GetForce(){ return force; }
  float GetTorqueReaction(){ return torqueReaction; }

  float getEndBrakingTorqueForWheel(CK3dEntity *wheelReference);
  float getEndTorqueForWheel(CK3dEntity *wheelReference);
  float getEndAccForWheel(CK3dEntity *wheelReference);

  float rotationalEndFactor;

  float timeScale;
  
  float getTimeScale() const { return timeScale; }
  void setTimeScale(float val) { timeScale = val; }

  float getEndRotationalFactor() { return rotationalEndFactor; }
  void setEndRotationalFactor(float val) { rotationalEndFactor = val; }


  //float GetRollingFrictionCoeff(){ return rollingFrictionCoeff; }

};

#endif
