<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>vtPhysX: pRigidBody Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="online.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>pRigidBody Class Reference<br/>
<small>
[<a class="el" href="group___rigid_body.html">RigidBody</a>]</small>
</h1><!-- doxytag: class="pRigidBody" --><!-- doxytag: inherits="xEngineObjectAssociation,pCallbackObject" -->
<p><a class="el" href="classp_rigid_body.html" title="pRigidBody is the main simulation object in the physics SDK.">pRigidBody</a> is the main simulation object in the physics SDK.  
<a href="#_details">More...</a></p>

<p>Inherits xEngineObjectAssociation&lt; CK3dEntity * &gt;, and pCallbackObject.</p>

<p><a href="classp_rigid_body-members.html">List of all members.</a></p>
<h2>Callback handler</h2>
<p><a class="anchor" id="amgrp7e6ff6834488281a31e414f7554b7110"></a> </p>
<ul>
<li><a class="anchor" id="ae4a33b3f936b02b5cf042f3aca7adb2e"></a><!-- doxytag: member="pRigidBody::onSubShapeTransformation" ref="ae4a33b3f936b02b5cf042f3aca7adb2e" args="(bool fromPhysicToVirtools=true, bool position=true, bool rotation=true, CK3dEntity *parent=NULL, bool children=true)" -->
bool <b>onSubShapeTransformation</b> (bool fromPhysicToVirtools=true, bool position=true, bool rotation=true, CK3dEntity *parent=NULL, bool children=true)
<li><a class="anchor" id="ad178e23482708baae3e94146b529e2a3"></a><!-- doxytag: member="pRigidBody::onMove" ref="ad178e23482708baae3e94146b529e2a3" args="(bool position, bool rotation, VxVector pos, VxQuaternion quad)" -->
bool <b>onMove</b> (bool position, bool rotation, VxVector pos, VxQuaternion quad)
<li><a class="anchor" id="a5c97d542927a7080d42eb58aa119ca50"></a><!-- doxytag: member="pRigidBody::processScriptCallbacks" ref="a5c97d542927a7080d42eb58aa119ca50" args="()" -->
void <b>processScriptCallbacks</b> ()
<li><a class="anchor" id="adf337b51570b1b8224d07810fb9be28e"></a><!-- doxytag: member="pRigidBody::onContactNotify" ref="adf337b51570b1b8224d07810fb9be28e" args="(pCollisionsEntry *collisionData)" -->
void <b>onContactNotify</b> (pCollisionsEntry *collisionData)
<li><a class="anchor" id="a614c98e26228769711a48f8aa6704db1"></a><!-- doxytag: member="pRigidBody::setContactScript" ref="a614c98e26228769711a48f8aa6704db1" args="(int behaviorID, int eventMask)" -->
void <b>setContactScript</b> (int behaviorID, int eventMask)
<li>void <a class="el" href="classp_rigid_body.html#ac4553803b16df9a3625fb40c6d3bd158">setContactReportThreshold</a> (float threshold)
<dl class="el"><dd class="mdescRight">Sets the force threshold for contact reports.  <a href="#ac4553803b16df9a3625fb40c6d3bd158"></a><br/></dl><li>float <a class="el" href="classp_rigid_body.html#abc2a3bceff295597739a3752fce6801d">getContactReportThreshold</a> ()
<dl class="el"><dd class="mdescRight">Retrieves the force threshold for contact reports.  <a href="#abc2a3bceff295597739a3752fce6801d"></a><br/></dl><li><a class="anchor" id="a1f5eecf32467d73d2c357e710762bd76"></a><!-- doxytag: member="pRigidBody::setContactReportFlags" ref="a1f5eecf32467d73d2c357e710762bd76" args="(pContactPairFlags flags)" -->
void <b>setContactReportFlags</b> (<a class="el" href="group___collision.html#ga9aa8c45bec8cddfa80d1ab556ff18579">pContactPairFlags</a> flags)
<li><a class="anchor" id="a8d3b08b84bc7c481a4575a9dc16d413f"></a><!-- doxytag: member="pRigidBody::getContactReportFlags" ref="a8d3b08b84bc7c481a4575a9dc16d413f" args="()" -->
int <b>getContactReportFlags</b> ()
<li><a class="anchor" id="aad1f48d75699933f96b21c64d27cd966"></a><!-- doxytag: member="pRigidBody::setTriggerScript" ref="aad1f48d75699933f96b21c64d27cd966" args="(int behaviorID, int eventMask, CK3dEntity *shapeReference=NULL)" -->
void <b>setTriggerScript</b> (int behaviorID, int eventMask, CK3dEntity *shapeReference=NULL)
<li><a class="anchor" id="a5d60b1ded0e13a5fc0ffb478dfa15bbf"></a><!-- doxytag: member="pRigidBody::onTrigger" ref="a5d60b1ded0e13a5fc0ffb478dfa15bbf" args="(pTriggerEntry *report)" -->
int <b>onTrigger</b> (pTriggerEntry *report)
<li><a class="anchor" id="a30ae6e9797ace884672ca57d6206fc2e"></a><!-- doxytag: member="pRigidBody::setContactModificationScript" ref="a30ae6e9797ace884672ca57d6206fc2e" args="(int behaviorID)" -->
void <b>setContactModificationScript</b> (int behaviorID)
<li><a class="anchor" id="a039c10d580b53fbb4d3f6e21a406d632"></a><!-- doxytag: member="pRigidBody::onContactConstraint" ref="a039c10d580b53fbb4d3f6e21a406d632" args="(int &amp;changeFlags, CK3dEntity *sourceObject, CK3dEntity *otherObject, pContactModifyData *data)" -->
bool <b>onContactConstraint</b> (int &amp;changeFlags, CK3dEntity *sourceObject, CK3dEntity *otherObject, pContactModifyData *data)
<li><a class="anchor" id="af08540dc8c2fbed7b09cf207345dffb2"></a><!-- doxytag: member="pRigidBody::setRayCastScript" ref="af08540dc8c2fbed7b09cf207345dffb2" args="(int val)" -->
virtual void <b>setRayCastScript</b> (int val)
<li><a class="anchor" id="a2a5fa35886c6bf1d0f21d166b59dd931"></a><!-- doxytag: member="pRigidBody::onRayCastHit" ref="a2a5fa35886c6bf1d0f21d166b59dd931" args="(NxRaycastHit *report)" -->
virtual bool <b>onRayCastHit</b> (NxRaycastHit *report)
</ul>
<h2>Collision</h2>
<p><a class="anchor" id="amgrp15fb6ccbd11ebebcea2b48dc477f3561"></a> </p>
<ul>
<li><a class="anchor" id="acada273dd25308803688658bd38dabf2"></a><!-- doxytag: member="pRigidBody::setTriggerFlags" ref="acada273dd25308803688658bd38dabf2" args="(pTriggerFlags flags, CKBeObject *shapeReference=NULL)" -->
void <b>setTriggerFlags</b> (<a class="el" href="group___collision.html#gaef8f69c493ccaadb80869ed879ddd4fa">pTriggerFlags</a> flags, CKBeObject *shapeReference=NULL)
<li><a class="anchor" id="a962bf37fc3f2930b1378a610ac08f4e6"></a><!-- doxytag: member="pRigidBody::getTriggerFlags" ref="a962bf37fc3f2930b1378a610ac08f4e6" args="(CKBeObject *shapeReference=NULL)" -->
<a class="el" href="group___collision.html#gaef8f69c493ccaadb80869ed879ddd4fa">pTriggerFlags</a> <b>getTriggerFlags</b> (CKBeObject *shapeReference=NULL)
<li><a class="anchor" id="ab6d9aab98c3e49945c7ca8da58d773a4"></a><!-- doxytag: member="pRigidBody::handleContactPair" ref="ab6d9aab98c3e49945c7ca8da58d773a4" args="(NxContactPair *pair, int shapeIndex)" -->
int <b>handleContactPair</b> (NxContactPair *pair, int shapeIndex)
<li><a class="anchor" id="acc0368b2f0a69a7889c409b66c2aad2f"></a><!-- doxytag: member="pRigidBody::handleContactPairWheel" ref="acc0368b2f0a69a7889c409b66c2aad2f" args="(NxContactPair *pair, int shapeIndex)" -->
int <b>handleContactPairWheel</b> (NxContactPair *pair, int shapeIndex)
<li>void <a class="el" href="classp_rigid_body.html#afec9beee8ee11d301d3bc6347b0e17a0">setGroupsMask</a> (CK3dEntity *shapeReference, const <a class="el" href="classp_groups_mask.html">pGroupsMask</a> &amp;mask)
<dl class="el"><dd class="mdescRight">Sets 128-bit mask used for collision filtering. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.  <a href="#afec9beee8ee11d301d3bc6347b0e17a0"></a><br/></dl><li><a class="anchor" id="a3702d806f7907bf25f74bdd78952dc0e"></a><!-- doxytag: member="pRigidBody::getGroupsMask" ref="a3702d806f7907bf25f74bdd78952dc0e" args="(CK3dEntity *shapeReference)" -->
<a class="el" href="classp_groups_mask.html">pGroupsMask</a> <b>getGroupsMask</b> (CK3dEntity *shapeReference)
<li>void <a class="el" href="classp_rigid_body.html#a2a664ddfb6ab190b63cfb0eed7089ce5">enableCollision</a> (bool enable, CK3dEntity *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Enables/disable collision detection. I.e. the body will not collide with other objects. Please note that you might need to wake the body up if it is sleeping, this depends on the result you wish to get when using this flag. (If a body is asleep it will not start to fall through objects unless you activate it).  <a href="#a2a664ddfb6ab190b63cfb0eed7089ce5"></a><br/></dl><li><a class="anchor" id="ab5db696d0d5e2ddfeca63b11f280db49"></a><!-- doxytag: member="pRigidBody::isCollisionEnabled" ref="ab5db696d0d5e2ddfeca63b11f280db49" args="(CK3dEntity *subShapeReference=NULL)" -->
bool <b>isCollisionEnabled</b> (CK3dEntity *subShapeReference=NULL)
<li><a class="anchor" id="a3fb6d4d4db269ea19a232fae191175f0"></a><!-- doxytag: member="pRigidBody::enableCollisionsNotify" ref="a3fb6d4d4db269ea19a232fae191175f0" args="(bool enable)" -->
void <b>enableCollisionsNotify</b> (bool enable)
<li><a class="anchor" id="abf0214eb74c3739250a7501845ce23d1"></a><!-- doxytag: member="pRigidBody::isCollisionsNotifyEnabled" ref="abf0214eb74c3739250a7501845ce23d1" args="()" -->
bool <b>isCollisionsNotifyEnabled</b> ()
<li><a class="anchor" id="a85f52803b802a5d65d670b8829343d23"></a><!-- doxytag: member="pRigidBody::enableContactModification" ref="a85f52803b802a5d65d670b8829343d23" args="(bool enable)" -->
void <b>enableContactModification</b> (bool enable)
<li><a class="anchor" id="a7ab04814b2724658953099d44942834b"></a><!-- doxytag: member="pRigidBody::enableCollisionForceCalculation" ref="a7ab04814b2724658953099d44942834b" args="(bool enable, CK3dEntity *subShapeReference=NULL)" -->
void <b>enableCollisionForceCalculation</b> (bool enable, CK3dEntity *subShapeReference=NULL)
<li><a class="anchor" id="abc630e241b1a57699483ba2ea0d6ab43"></a><!-- doxytag: member="pRigidBody::enableTriggerShape" ref="abc630e241b1a57699483ba2ea0d6ab43" args="(bool enable, CK3dEntity *subShapeReference=NULL)" -->
void <b>enableTriggerShape</b> (bool enable, CK3dEntity *subShapeReference=NULL)
<li><a class="anchor" id="a17c3856fe60cf56362a1b095b0e5dbec"></a><!-- doxytag: member="pRigidBody::isTriggerShape" ref="a17c3856fe60cf56362a1b095b0e5dbec" args="(CK3dEntity *subShapeReference=NULL)" -->
bool <b>isTriggerShape</b> (CK3dEntity *subShapeReference=NULL)
<li>void <a class="el" href="classp_rigid_body.html#a4f55366c796d18a6b1ebfc1b5051d912">setCollisionsGroup</a> (int index, CK3dEntity *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Sets the collisions group the body belongs too.  <a href="#a4f55366c796d18a6b1ebfc1b5051d912"></a><br/></dl><li>int <a class="el" href="classp_rigid_body.html#a6503353b83ea152c55cea6bccfd51dd7">getCollisionsGroup</a> (CK3dEntity *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Retrieves the collisions group which this body or a sub shape of it is part of.  <a href="#a6503353b83ea152c55cea6bccfd51dd7"></a><br/></dl></ul>
<h2>Velocity</h2>
<p><a class="anchor" id="amgrp88156d46910a2d733443c339a9231d12"></a> </p>
<ul>
<li>VxVector <a class="el" href="classp_rigid_body.html#a920265caf5b7cda64f7337a3af3cf944">getAngularVelocity</a> () const 
<dl class="el"><dd class="mdescRight">Retrieves the angular velocity of a rigid body.  <a href="#a920265caf5b7cda64f7337a3af3cf944"></a><br/></dl><li>VxVector <a class="el" href="classp_rigid_body.html#a4a49aaa54acc44bb804a987a43714154">getLinearVelocity</a> () const 
<dl class="el"><dd class="mdescRight">Retrieves the linear velocity of a rigid body.  <a href="#a4a49aaa54acc44bb804a987a43714154"></a><br/></dl><li>float <a class="el" href="classp_rigid_body.html#a0bee1191e144987d87da0e7adbb6b6e7">getMaxAngularSpeed</a> () const 
<dl class="el"><dd class="mdescRight">Retrieves the maximum angular velocity permitted for this body.  <a href="#a0bee1191e144987d87da0e7adbb6b6e7"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#ae748544ad701d5ff69a87f7a447028e5">setMaxAngularSpeed</a> (float val)
<dl class="el"><dd class="mdescRight">Lets you set the maximum angular velocity permitted for this body.  <a href="#ae748544ad701d5ff69a87f7a447028e5"></a><br/></dl><li>VxVector <a class="el" href="classp_rigid_body.html#a4581aaee3d75fdad98b975ef4bc5f58e">getPointVelocity</a> (const VxVector &amp;point) const 
<dl class="el"><dd class="mdescRight">Computes the velocity of a point given in body local coordinates as if it were attached to the body and moving with it.  <a href="#a4581aaee3d75fdad98b975ef4bc5f58e"></a><br/></dl><li>VxVector <a class="el" href="classp_rigid_body.html#a5dad44eb149b3708a945541cb2232c12">getLocalPointVelocity</a> (const VxVector &amp;point) const 
<dl class="el"><dd class="mdescRight">Computes the velocity of a point given in body local coordinates as if it were attached to the body and moving with it.  <a href="#a5dad44eb149b3708a945541cb2232c12"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#ad57783ac85abda1a74d74e13cc583d6f">setAngularVelocity</a> (const VxVector &amp;angVel)
<dl class="el"><dd class="mdescRight">Sets the angular velocity of the body.  <a href="#ad57783ac85abda1a74d74e13cc583d6f"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#ab6457b27b73b83985bd2572dba54976c">setLinearVelocity</a> (const VxVector &amp;linVel)
<dl class="el"><dd class="mdescRight">Sets the linear velocity of the body.  <a href="#ab6457b27b73b83985bd2572dba54976c"></a><br/></dl></ul>
<h2>Mass</h2>
<p><a class="anchor" id="amgrpff2864d6f652ee0ac254814f1ae4f4a8"></a> </p>
<ul>
<li>float <a class="el" href="classp_rigid_body.html#a667a150028810d7564b65cb95d09bcba">getMass</a> (CK3dEntity *shapeReference=NULL)
<dl class="el"><dd class="mdescRight">Retrieves the mass of the body.  <a href="#a667a150028810d7564b65cb95d09bcba"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#ad40fd79662b72c1effc0c2b21bf32150">setMass</a> (float mass, CKBeObject *shapeReference=NULL)
<dl class="el"><dd class="mdescRight">Sets the mass of a dynamic body.  <a href="#ad40fd79662b72c1effc0c2b21bf32150"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#a6070a3b1f3307550789c46d945316f76">setCMassOffsetLocalPosition</a> (VxVector offset)
<dl class="el"><dd class="mdescRight">The setCMassOffsetLocal*() methods set the pose of the center of mass relative to the body.  <a href="#a6070a3b1f3307550789c46d945316f76"></a><br/></dl><li>int <a class="el" href="classp_rigid_body.html#a006c18f270a92193f26e9a89abf6276d">updateMassFromShapes</a> (float density, float totalMass)
<dl class="el"><dd class="mdescRight">Recomputes a dynamic body's mass properties from its shapes.  <a href="#a006c18f270a92193f26e9a89abf6276d"></a><br/></dl></ul>
<h2>Forces</h2>
<p><a class="anchor" id="amgrpa106ee7abe6c52a7443defa96e17b7af"></a> </p>
<ul>
<li>void <a class="el" href="classp_rigid_body.html#ac482b4f236cfa368704f7c802003b75f">addForce</a> (const VxVector &amp;force, <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> mode=FM_Force, bool wakeUp=true)
<dl class="el"><dd class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame to the body.  <a href="#ac482b4f236cfa368704f7c802003b75f"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#a15079127af14b3dd3c96d6c84ad860f0">addForceAtPos</a> (const VxVector &amp;force, const VxVector &amp;point, <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> mode=FM_Force, bool wakeUp=true)
<dl class="el"><dd class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in global coordinates, to the body.  <a href="#a15079127af14b3dd3c96d6c84ad860f0"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#abc4363e2b26177fce66f63a6efe85553">addForceAtLocalPos</a> (const VxVector &amp;force, const VxVector &amp;point, <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> mode=FM_Force, bool wakeUp=true)
<dl class="el"><dd class="mdescRight">Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in local coordinates, to the body.  <a href="#abc4363e2b26177fce66f63a6efe85553"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#ad108083a58222d1bfdd4e2eaa4a174e3">addLocalForce</a> (const VxVector &amp;force, <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> mode=FM_Force, bool wakeUp=true)
<dl class="el"><dd class="mdescRight">Applies a force (or impulse) defined in the body local coordinate frame to the body.  <a href="#ad108083a58222d1bfdd4e2eaa4a174e3"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#a04cd52f7d438447893c2c447a05f7e25">addLocalForceAtPos</a> (const VxVector &amp;force, const VxVector &amp;point, <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> mode=FM_Force, bool wakeUp=true)
<dl class="el"><dd class="mdescRight">Applies a force (or impulse) defined in the body local coordinate frame, acting at a particular point in global coordinates, to the body.  <a href="#a04cd52f7d438447893c2c447a05f7e25"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#aa4260645981771a6595ce6b1df166e43">addLocalForceAtLocalPos</a> (const VxVector &amp;force, const VxVector &amp;point, <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> mode=FM_Force, bool wakeUp=true)
<dl class="el"><dd class="mdescRight">Applies a force (or impulse) defined in the body local coordinate frame, acting at a particular point in local coordinates, to the body.  <a href="#aa4260645981771a6595ce6b1df166e43"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#a56abbb3058367ecd8d4e7a81edd4a94f">addTorque</a> (const VxVector &amp;torque, <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> mode=FM_Force, bool wakeUp=true)
<dl class="el"><dd class="mdescRight">Applies an impulsive torque defined in the global coordinate frame to the body.  <a href="#a56abbb3058367ecd8d4e7a81edd4a94f"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#a6a95f5df5d9f89e5eaed2520cb0801c7">addLocalTorque</a> (const VxVector &amp;torque, <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> mode=FM_Force, bool wakeUp=true)
<dl class="el"><dd class="mdescRight">Applies an impulsive torque defined in the body local coordinate frame to the body.  <a href="#a6a95f5df5d9f89e5eaed2520cb0801c7"></a><br/></dl></ul>
<h2>Momentum</h2>
<p><a class="anchor" id="amgrp37323780191d51a33d295ac10fb98f06"></a> </p>
<ul>
<li>void <a class="el" href="classp_rigid_body.html#a50e446c8f5e2357025e7627eb66e7349">setAngularMomentum</a> (const VxVector &amp;angMoment)
<dl class="el"><dd class="mdescRight">Sets the angular momentum of the body.  <a href="#a50e446c8f5e2357025e7627eb66e7349"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#ac13b3422ceb584a984c4083c50e7028c">setLinearMomentum</a> (const VxVector &amp;linMoment)
<dl class="el"><dd class="mdescRight">Sets the linear momentum of the body.  <a href="#ac13b3422ceb584a984c4083c50e7028c"></a><br/></dl><li>VxVector <a class="el" href="classp_rigid_body.html#a868460d2e91c1785911f4f2e008eaa29">getAngularMomentum</a> () const 
<dl class="el"><dd class="mdescRight">Retrieves the angular momentum of an body.  <a href="#a868460d2e91c1785911f4f2e008eaa29"></a><br/></dl><li>VxVector <a class="el" href="classp_rigid_body.html#a6665707a48b4a798cb2128b279fd802e">getLinearMomentum</a> () const 
<dl class="el"><dd class="mdescRight">Retrieves the linear momentum of an body.  <a href="#a6665707a48b4a798cb2128b279fd802e"></a><br/></dl></ul>
<h2>Pose</h2>
<p><a class="anchor" id="amgrp8109c9c9d6a2ca3bec3e006fe51a5f3e"></a> </p>
<ul>
<li>void <a class="el" href="classp_rigid_body.html#adcfdf047b1e5ca33927431c6a066ff1d">setPosition</a> (const VxVector &amp;pos, CK3dEntity *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Sets a dynamic body's position in the world.  <a href="#adcfdf047b1e5ca33927431c6a066ff1d"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#af0f06d6da8310eb62d4ad33fb9f14258">setRotation</a> (const VxQuaternion &amp;rot, CK3dEntity *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Sets a dynamic body's orientation in the world.  <a href="#af0f06d6da8310eb62d4ad33fb9f14258"></a><br/></dl></ul>
<h2>Shape</h2>
<p><a class="anchor" id="amgrp880c1273b27d27cfc82004c3a4b205c9"></a> </p>
<ul>
<li>void <a class="el" href="classp_rigid_body.html#abc939d1610cf66b1cc71556d93317a53">setBoxDimensions</a> (const VxVector &amp;dimension, CKBeObject *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Updates the box dimension of the initial shape or a sub shape.  <a href="#abc939d1610cf66b1cc71556d93317a53"></a><br/></dl><li>VxVector <a class="el" href="classp_rigid_body.html#a3e61f7a180d478c3486e0f5db24b0ffc">getBoxDimensions</a> (CKBeObject *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Retrieves the box dimension of the initial shape or sub shape.  <a href="#a3e61f7a180d478c3486e0f5db24b0ffc"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#a7f9ade29e66eab080827a61214542d0b">setSphereRadius</a> (float radius, CKBeObject *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Updates the radius of the initial shape or a sub shape.  <a href="#a7f9ade29e66eab080827a61214542d0b"></a><br/></dl><li>float <a class="el" href="classp_rigid_body.html#ad8ac70192f2e743dc598abb492ade6df">getSphereRadius</a> (CKBeObject *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Retrieves the radius of the initial shape or sub shape.  <a href="#ad8ac70192f2e743dc598abb492ade6df"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#af613fc26ae60a10f8eec06c21792bfc4">setCapsuleDimensions</a> (float radius, float length, CKBeObject *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Updates the capsule parameter of the initial shape or a sub shape.  <a href="#af613fc26ae60a10f8eec06c21792bfc4"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#afcbabe0545196c9d6a5f74ab9d89829b">getCapsuleDimensions</a> (float &amp;radius, float &amp;length, CKBeObject *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Retrieves the capsule parameters of the initial shape or sub shape.  <a href="#afcbabe0545196c9d6a5f74ab9d89829b"></a><br/></dl><li><a class="el" href="group___rigid_body.html#gae3a18d6e3dcbff2fbc246b48960a94d9">HullType</a> <a class="el" href="classp_rigid_body.html#aed769a9e939a44c34eb58d6f26c311ee">getShapeType</a> (CKBeObject *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Retrieves the hull type of the initial shape or sub shape.  <a href="#aed769a9e939a44c34eb58d6f26c311ee"></a><br/></dl><li>float <a class="el" href="classp_rigid_body.html#a881a845ee955bfa165da8fbe4572ef35">getSkinWidth</a> (CKBeObject *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Retrieves the skin width of the initial shape or a sub shape.  <a href="#a881a845ee955bfa165da8fbe4572ef35"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#a3ae1d99f2f8466512eba4ed7e5f52503">setSkinWidth</a> (const float skinWidth, CKBeObject *subShapeReference=NULL)
<dl class="el"><dd class="mdescRight">Updates the skin width of the initial shape or a sub shape.  <a href="#a3ae1d99f2f8466512eba4ed7e5f52503"></a><br/></dl></ul>
<h2>Optimization</h2>
<p><a class="anchor" id="amgrp15970c4fdbca1fc48c5b412d94e798c0"></a> </p>
<ul>
<li>void <a class="el" href="classp_rigid_body.html#aa2af58f48c0f1b2b14da6138b62681e3">setSolverIterationCount</a> (int count)
<dl class="el"><dd class="mdescRight">The solver iteration count determines how accurately joints and contacts are resolved. <br/>
 If you are having trouble with jointed bodies oscillating and behaving erratically, then setting a higher solver iteration count may improve their stability.  <a href="#aa2af58f48c0f1b2b14da6138b62681e3"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#a3d726f61561e40fd3baf20d1d2463030">setDominanceGroup</a> (int dominanceGroup)
<dl class="el"><dd class="mdescRight">Assigns dynamic bodies a dominance group identifier.<br/>
.  <a href="#a3d726f61561e40fd3baf20d1d2463030"></a><br/></dl><li>int <a class="el" href="classp_rigid_body.html#a26f85f61fde9a083fed8d7bf06bf2a86">getDominanceGroup</a> () const 
<dl class="el"><dd class="mdescRight">Retrieves the value set with <a class="el" href="classp_rigid_body.html#a3d726f61561e40fd3baf20d1d2463030" title="Assigns dynamic bodies a dominance group identifier. .">setDominanceGroup()</a>.<br/>
.  <a href="#a26f85f61fde9a083fed8d7bf06bf2a86"></a><br/></dl><li>float <a class="el" href="classp_rigid_body.html#a02b9c7d5b91381ebfa2ba60751a4d3f4">getSleepLinearVelocity</a> () const 
<dl class="el"><dd class="mdescRight">Returns the linear velocity below which an body may go to sleep.<br/>
.  <a href="#a02b9c7d5b91381ebfa2ba60751a4d3f4"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#ae3fc1b6670fc28fbc727d73278c88341">setSleepLinearVelocity</a> (float threshold)
<dl class="el"><dd class="mdescRight">Sets the linear velocity below which an body may go to sleep.<br/>
.  <a href="#ae3fc1b6670fc28fbc727d73278c88341"></a><br/></dl><li>float <a class="el" href="classp_rigid_body.html#af340cba727c9ef5ab0aa458f9e63ef1d">getSleepAngularVelocity</a> () const 
<dl class="el"><dd class="mdescRight">Returns the angular velocity below which an body may go to sleep.<br/>
.  <a href="#af340cba727c9ef5ab0aa458f9e63ef1d"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#ac4ba53cdf6c539fbbbe79b11dd71feb6">setSleepAngularVelocity</a> (float threshold)
<dl class="el"><dd class="mdescRight">Sets the angular velocity below which an body may go to sleep.<br/>
.  <a href="#ac4ba53cdf6c539fbbbe79b11dd71feb6"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#aff87a911b4ea2235ce32336e2b51cfc2">setSleepEnergyThreshold</a> (float threshold)
<dl class="el"><dd class="mdescRight">Sets the energy threshold below which an body may go to sleep.<br/>
.  <a href="#aff87a911b4ea2235ce32336e2b51cfc2"></a><br/></dl><li>float <a class="el" href="classp_rigid_body.html#a4f7277b57cad3cefcb71a4ef7f801137">getSleepEnergyThreshold</a> () const 
<dl class="el"><dd class="mdescRight">Returns the energy below which an body may go to sleep.<br/>
.  <a href="#a4f7277b57cad3cefcb71a4ef7f801137"></a><br/></dl><li>float <a class="el" href="classp_rigid_body.html#ac2f207318511894b2f00badc13f61387">getLinearDamping</a> () const 
<dl class="el"><dd class="mdescRight">Retrieves the linear damping coefficient.<br/>
.  <a href="#ac2f207318511894b2f00badc13f61387"></a><br/></dl><li>float <a class="el" href="classp_rigid_body.html#abc2a65fc7cf009e0c5968141b795fdd8">getAngularDamping</a> () const 
<dl class="el"><dd class="mdescRight">Retrieves the angular damping coefficient.<br/>
.  <a href="#abc2a65fc7cf009e0c5968141b795fdd8"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#ab4bda541734ab40c7fff21e25c65ff0c">setLinearDamping</a> (float linDamp)
<dl class="el"><dd class="mdescRight">Sets the linear damping coefficient.<br/>
.  <a href="#ab4bda541734ab40c7fff21e25c65ff0c"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#a2ccb6e3bbfda60f37497109db6a36c96">setAngularDamping</a> (float angDamp)
<dl class="el"><dd class="mdescRight">Sets the angular damping coefficient.<br/>
.  <a href="#a2ccb6e3bbfda60f37497109db6a36c96"></a><br/></dl></ul>
<h2>Conditions</h2>
<p><a class="anchor" id="amgrp229eb04083e06f419f9ac494329f957d"></a> </p>
<ul>
<li>void <a class="el" href="classp_rigid_body.html#aa306df591c61f966ba92241eb4a5948f">setKinematic</a> (bool enabled)
<dl class="el"><dd class="mdescRight">Sets the body to kinematic.  <a href="#aa306df591c61f966ba92241eb4a5948f"></a><br/></dl><li>bool <a class="el" href="classp_rigid_body.html#a1553e9d81b65564e30233fa3644673da">isKinematic</a> () const 
<dl class="el"><dd class="mdescRight">Retrieves the bodies kinematic state.  <a href="#a1553e9d81b65564e30233fa3644673da"></a><br/></dl><li>bool <a class="el" href="classp_rigid_body.html#a427c31038418ab1043f9565359e9b008">isAffectedByGravity</a> () const 
<dl class="el"><dd class="mdescRight">Checks whether the body is affected by the worlds gravity.  <a href="#a427c31038418ab1043f9565359e9b008"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#ac4ed1df73b118b420638dc24a7f733a1">enableGravity</a> (bool enable)
<dl class="el"><dd class="mdescRight">Enables gravity on the body.  <a href="#ac4ed1df73b118b420638dc24a7f733a1"></a><br/></dl></ul>
<h2>Sleeping</h2>
<p><a class="anchor" id="amgrpbddd4f44136f466c065a2c7a4c53e75b"></a> </p>
<ul>
<li>bool <a class="el" href="classp_rigid_body.html#ab88f1af6b55b5ae2e01e7de5938ed68c">isSleeping</a> () const 
<dl class="el"><dd class="mdescRight">Checks whether the body is in a sleeping state.  <a href="#ab88f1af6b55b5ae2e01e7de5938ed68c"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#a068a21eae07470cab4ae565ac5d4f62b">setSleeping</a> (bool sleeping)
<dl class="el"><dd class="mdescRight">Forces the body to sleep.  <a href="#a068a21eae07470cab4ae565ac5d4f62b"></a><br/></dl><li>void <a class="el" href="classp_rigid_body.html#a0194f95349781d1fa4c1a99fce612613">wakeUp</a> (float wakeCounterValue=pSLEEP_INTERVAL)
<dl class="el"><dd class="mdescRight">Wakes up the body if it is sleeping.  <a href="#a0194f95349781d1fa4c1a99fce612613"></a><br/></dl></ul>
<h2>Sub shapes</h2>
<p><a class="anchor" id="amgrp147d5cc0004c5eafc9889ca78e433433"></a> </p>
<ul>
<li><a class="anchor" id="abb8a9e992c1459176fefc42e3db62715"></a><!-- doxytag: member="pRigidBody::addSubShape" ref="abb8a9e992c1459176fefc42e3db62715" args="(CKMesh *mesh, pObjectDescr &amp;objectDescr, CK3dEntity *srcRefEntity=NULL, VxVector localPosition=VxVector(), VxQuaternion localRotation=VxQuaternion())" -->
int <b>addSubShape</b> (CKMesh *mesh, <a class="el" href="classp_object_descr.html">pObjectDescr</a> &amp;objectDescr, CK3dEntity *srcRefEntity=NULL, VxVector localPosition=VxVector(), VxQuaternion localRotation=VxQuaternion())
<li><a class="anchor" id="a49abbe8b9777e5a6f0718636b76aa5a1"></a><!-- doxytag: member="pRigidBody::addCollider" ref="a49abbe8b9777e5a6f0718636b76aa5a1" args="(pObjectDescr objectDescr, CK3dEntity *srcRefEntity)" -->
int <b>addCollider</b> (<a class="el" href="classp_object_descr.html">pObjectDescr</a> objectDescr, CK3dEntity *srcRefEntity)
<li><a class="anchor" id="a386180b94d09a6f95e8003c8feec241b"></a><!-- doxytag: member="pRigidBody::removeSubShape" ref="a386180b94d09a6f95e8003c8feec241b" args="(CKBeObject *reference, float newensity=0.0f, float totalMass=0.0f)" -->
int <b>removeSubShape</b> (CKBeObject *reference, float newensity=0.0f, float totalMass=0.0f)
<li><a class="anchor" id="a5958562805a0e90c85833f22560a2616"></a><!-- doxytag: member="pRigidBody::_getSubShape" ref="a5958562805a0e90c85833f22560a2616" args="(CK_ID meshID)" -->
NxShape * <b>_getSubShape</b> (CK_ID meshID)
<li><a class="anchor" id="ac90dfb725f97e919af9abf2e834fd482"></a><!-- doxytag: member="pRigidBody::_getSubShapeByEntityID" ref="ac90dfb725f97e919af9abf2e834fd482" args="(CK_ID id)" -->
NxShape * <b>_getSubShapeByEntityID</b> (CK_ID id)
<li><a class="anchor" id="a708643a1b3c40697422eb7ee18f0900c"></a><!-- doxytag: member="pRigidBody::isSubShape" ref="a708643a1b3c40697422eb7ee18f0900c" args="(CKBeObject *object)" -->
bool <b>isSubShape</b> (CKBeObject *object)
<li><a class="anchor" id="a22dedbb37df40088cd99072fe6d310e4"></a><!-- doxytag: member="pRigidBody::updateSubShapes" ref="a22dedbb37df40088cd99072fe6d310e4" args="(bool fromPhysicToVirtools=true, bool position=true, bool rotation=true, CK3dEntity *childObject=NULL)" -->
int <b>updateSubShapes</b> (bool fromPhysicToVirtools=true, bool position=true, bool rotation=true, CK3dEntity *childObject=NULL)
<li><a class="anchor" id="a35da56f1e3584cda6c7fae81ca18fd2e"></a><!-- doxytag: member="pRigidBody::updateSubShape" ref="a35da56f1e3584cda6c7fae81ca18fd2e" args="(bool fromPhysicToVirtools=true, bool position=true, bool rotation=true, CK3dEntity *childObject=NULL, bool hierarchy=true)" -->
int <b>updateSubShape</b> (bool fromPhysicToVirtools=true, bool position=true, bool rotation=true, CK3dEntity *childObject=NULL, bool hierarchy=true)
<li><a class="anchor" id="ae778c6fe59000907d86587a00ec5ff8c"></a><!-- doxytag: member="pRigidBody::getMainShape" ref="ae778c6fe59000907d86587a00ec5ff8c" args="() const " -->
NxShape * <b>getMainShape</b> () const 
<li><a class="anchor" id="a3a04e992c5af796e1502dae22ffeee2a"></a><!-- doxytag: member="pRigidBody::setMainShape" ref="a3a04e992c5af796e1502dae22ffeee2a" args="(NxShape *val)" -->
void <b>setMainShape</b> (NxShape *val)
<li><a class="anchor" id="af7978a28c42c5d830a7dbe11c4912459"></a><!-- doxytag: member="pRigidBody::getShapeByIndex" ref="af7978a28c42c5d830a7dbe11c4912459" args="(int index=0)" -->
NxShape * <b>getShapeByIndex</b> (int index=0)
<li><a class="anchor" id="a29a3a20c2fad4d46852f378f11c38889"></a><!-- doxytag: member="pRigidBody::getSubShape" ref="a29a3a20c2fad4d46852f378f11c38889" args="(CK3dEntity *shapeReference=NULL)" -->
NxShape * <b>getSubShape</b> (CK3dEntity *shapeReference=NULL)
</ul>
<h2>Serialization</h2>
<p><a class="anchor" id="amgrp1adb0c1dbe31b0bf5fa0665a823707a0"></a> </p>
<ul>
<li><a class="anchor" id="a10685ac908cba56d7be7b6fd4f16b9df"></a><!-- doxytag: member="pRigidBody::readFrom" ref="a10685ac908cba56d7be7b6fd4f16b9df" args="(NXU::NxActorDesc *desc, int flags)" -->
void <b>readFrom</b> (NXU::NxActorDesc *desc, int flags)
<li><a class="anchor" id="a88423dd67a687bde7df3466b90bb01ec"></a><!-- doxytag: member="pRigidBody::writeTo" ref="a88423dd67a687bde7df3466b90bb01ec" args="(const char *filename, int flags)" -->
void <b>writeTo</b> (const char *filename, int flags)
</ul>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="classp_rigid_body.html" title="pRigidBody is the main simulation object in the physics SDK.">pRigidBody</a> is the main simulation object in the physics SDK. </p>
<p>The body is owned by and contained in a <a class="el" href="classp_world.html" title="Class to maintain physical objects.">pWorld</a>.</p>
<h3>Creation</h3>
<p>Instances of this class are created by calling pFbodyy::createBody() and deleted with NxScene::deleteBody().</p>
<p>See <a class="el" href="classp_object_descr.html" title="Describes a rigid body.">pObjectDescr</a> for a more detailed description of the parameters which can be set when creating a body.</p>
<p>class MODULE_API <a class="el" href="classp_rigid_body.html" title="pRigidBody is the main simulation object in the physics SDK.">pRigidBody</a> : public xEngineObjectAssociation&lt;CK3dEntity*&gt;</p>
<p>class MODULE_API <a class="el" href="classp_rigid_body.html" title="pRigidBody is the main simulation object in the physics SDK.">pRigidBody</a> : public pStoredObjectAssociation&lt;CK3dEntity*,NxActor*&gt; </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ac4553803b16df9a3625fb40c6d3bd158"></a><!-- doxytag: member="pRigidBody::setContactReportThreshold" ref="ac4553803b16df9a3625fb40c6d3bd158" args="(float threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setContactReportThreshold </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the force threshold for contact reports. </p>
<p>See <a class="el" href="classp_rigid_body.html#abc2a3bceff295597739a3752fce6801d" title="Retrieves the force threshold for contact reports.">getContactReportThreshold()</a>.</p>
<p>The actor must be dynamic.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Force threshold for contact reports.</p>
<ul>
<li><b>Range:</b> (0,inf)</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#abc2a3bceff295597739a3752fce6801d" title="Retrieves the force threshold for contact reports.">getContactReportThreshold</a> getContactReportFlags pContactPairFlag </dd></dl>

</div>
</div>
<a class="anchor" id="abc2a3bceff295597739a3752fce6801d"></a><!-- doxytag: member="pRigidBody::getContactReportThreshold" ref="abc2a3bceff295597739a3752fce6801d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pRigidBody::getContactReportThreshold </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the force threshold for contact reports. </p>
<p>The contact report threshold is a force threshold. If the force between two actors exceeds this threshold for either of the two actors, a contact report will be generated according to the union of both body' contact report threshold flags. See getContactReportFlags().</p>
<p>The body must be dynamic. The threshold used for a collision between a dynamic actor and the static environment is the threshold of the dynamic actor, and all contacts with static actors are summed to find the total normal force.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Force threshold for contact reports.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ac4553803b16df9a3625fb40c6d3bd158" title="Sets the force threshold for contact reports.">setContactReportThreshold</a> getContactReportFlags pContactPairFlag </dd></dl>

</div>
</div>
<a class="anchor" id="afec9beee8ee11d301d3bc6347b0e17a0"></a><!-- doxytag: member="pRigidBody::setGroupsMask" ref="afec9beee8ee11d301d3bc6347b0e17a0" args="(CK3dEntity *shapeReference, const pGroupsMask &amp;mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setGroupsMask </td>
          <td>(</td>
          <td class="paramtype">CK3dEntity *&nbsp;</td>
          <td class="paramname"> <em>shapeReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classp_groups_mask.html">pGroupsMask</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mask</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets 128-bit mask used for collision filtering. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>. </p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the associated body up automatically.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shape</em>&nbsp;</td><td>Reference The sub shape reference object. Leave blank to set the bodies initial shapes groups mask. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>The group mask to set for the shape.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>getGroupsMask() </dd></dl>

</div>
</div>
<a class="anchor" id="a920265caf5b7cda64f7337a3af3cf944"></a><!-- doxytag: member="pRigidBody::getAngularVelocity" ref="a920265caf5b7cda64f7337a3af3cf944" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VxVector pRigidBody::getAngularVelocity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the angular velocity of a rigid body. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Vector</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ad57783ac85abda1a74d74e13cc583d6f" title="Sets the angular velocity of the body.">setAngularVelocity()</a> <a class="el" href="classp_rigid_body.html#a4a49aaa54acc44bb804a987a43714154" title="Retrieves the linear velocity of a rigid body.">getLinearVelocity()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a49aaa54acc44bb804a987a43714154"></a><!-- doxytag: member="pRigidBody::getLinearVelocity" ref="a4a49aaa54acc44bb804a987a43714154" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VxVector pRigidBody::getLinearVelocity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the linear velocity of a rigid body. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Vector </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ab6457b27b73b83985bd2572dba54976c" title="Sets the linear velocity of the body.">setLinearVelocity()</a> <a class="el" href="classp_rigid_body.html#a920265caf5b7cda64f7337a3af3cf944" title="Retrieves the angular velocity of a rigid body.">getAngularVelocity()</a> </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="a0bee1191e144987d87da0e7adbb6b6e7"></a><!-- doxytag: member="pRigidBody::getMaxAngularSpeed" ref="a0bee1191e144987d87da0e7adbb6b6e7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pRigidBody::getMaxAngularSpeed </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the maximum angular velocity permitted for this body. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>float </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>setMaxAngularVelocity </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="ae748544ad701d5ff69a87f7a447028e5"></a><!-- doxytag: member="pRigidBody::setMaxAngularSpeed" ref="ae748544ad701d5ff69a87f7a447028e5" args="(float val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setMaxAngularSpeed </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>val</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Lets you set the maximum angular velocity permitted for this body. </p>
<p>Because for various internal computations, very quickly rotating bodies introduce error into the simulation, which leads to undesired results.</p>
<p>With PhysicManager::setParameter(EX_MAX_ANGULAR_VELOCITY) you can set the default maximum velocity for bodies created after the call. Bodies' high angular velocities are clamped to this value.</p>
<p>However, because some bodies, such as car wheels, should be able to rotate quickly, you can override the default setting on a per-body basis with the below call. Note that objects such as wheels which are approximated with spherical or other smooth collision primitives can be simulated with stability at a much higher angular velocity than, say, a box that has corners.</p>
<p>Note: The angular velocity is clamped to the set value <em>before</em> the solver, which means that the limit may still be momentarily exceeded.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Max allowable angular velocity for body. <b>Range:</b> (0,inf)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>getMaxAngularVelocity()</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="a4581aaee3d75fdad98b975ef4bc5f58e"></a><!-- doxytag: member="pRigidBody::getPointVelocity" ref="a4581aaee3d75fdad98b975ef4bc5f58e" args="(const VxVector &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VxVector pRigidBody::getPointVelocity </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the velocity of a point given in body local coordinates as if it were attached to the body and moving with it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point</em>&nbsp;</td><td>Point we wish to determine the velocity of, defined in the body local frame. <b>Range:</b> position vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The velocity, in the global frame, of the point.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a5dad44eb149b3708a945541cb2232c12" title="Computes the velocity of a point given in body local coordinates as if it were attached...">getLocalPointVelocity()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="a5dad44eb149b3708a945541cb2232c12"></a><!-- doxytag: member="pRigidBody::getLocalPointVelocity" ref="a5dad44eb149b3708a945541cb2232c12" args="(const VxVector &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VxVector pRigidBody::getLocalPointVelocity </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the velocity of a point given in body local coordinates as if it were attached to the body and moving with it. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point</em>&nbsp;</td><td>Point we wish to determine the velocity of, defined in the body local frame. <b>Range:</b> position vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The velocity, in the global frame, of the point.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a4581aaee3d75fdad98b975ef4bc5f58e" title="Computes the velocity of a point given in body local coordinates as if it were attached...">getPointVelocity()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="ad57783ac85abda1a74d74e13cc583d6f"></a><!-- doxytag: member="pRigidBody::setAngularVelocity" ref="ad57783ac85abda1a74d74e13cc583d6f" args="(const VxVector &amp;angVel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setAngularVelocity </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>angVel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the angular velocity of the body. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Note that if you continuously set the angular velocity of an body yourself, forces such as friction will not be able to rotate the body, because forces directly influence only the velocity/momentum.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angVel</em>&nbsp;</td><td>New angular velocity of body. <b>Range:</b> angular velocity vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a920265caf5b7cda64f7337a3af3cf944" title="Retrieves the angular velocity of a rigid body.">getAngularVelocity()</a> <a class="el" href="classp_rigid_body.html#ab6457b27b73b83985bd2572dba54976c" title="Sets the linear velocity of the body.">setLinearVelocity()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>Sleeping:</b> This call wakes the body if it is sleeping. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6457b27b73b83985bd2572dba54976c"></a><!-- doxytag: member="pRigidBody::setLinearVelocity" ref="ab6457b27b73b83985bd2572dba54976c" args="(const VxVector &amp;linVel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setLinearVelocity </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>linVel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the linear velocity of the body. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Note that if you continuously set the velocity of an body yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of an body.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linVel</em>&nbsp;</td><td>New linear velocity of body. <b>Range:</b> velocity vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a4a49aaa54acc44bb804a987a43714154" title="Retrieves the linear velocity of a rigid body.">getLinearVelocity()</a> <a class="el" href="classp_rigid_body.html#ad57783ac85abda1a74d74e13cc583d6f" title="Sets the angular velocity of the body.">setAngularVelocity()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>Sleeping:</b> This call wakes the body if it is sleeping. </dd></dl>

</div>
</div>
<a class="anchor" id="a667a150028810d7564b65cb95d09bcba"></a><!-- doxytag: member="pRigidBody::getMass" ref="a667a150028810d7564b65cb95d09bcba" args="(CK3dEntity *shapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pRigidBody::getMass </td>
          <td>(</td>
          <td class="paramtype">CK3dEntity *&nbsp;</td>
          <td class="paramname"> <em>shapeReference</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the mass of the body. </p>
<p>Zero represents no damping. The damping coefficient must be nonnegative.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angDamp</em>&nbsp;</td><td>Angular damping coefficient. <b>Range:</b> [0,inf)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ad40fd79662b72c1effc0c2b21bf32150" title="Sets the mass of a dynamic body.">setMass()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>Static bodies will always return 0. </dd></dl>

</div>
</div>
<a class="anchor" id="ad40fd79662b72c1effc0c2b21bf32150"></a><!-- doxytag: member="pRigidBody::setMass" ref="ad40fd79662b72c1effc0c2b21bf32150" args="(float mass, CKBeObject *shapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setMass </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKBeObject *&nbsp;</td>
          <td class="paramname"> <em>shapeReference</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the mass of a dynamic body. </p>
<p>The mass must be positive and the body must be dynamic.</p>
<p><a class="el" href="classp_rigid_body.html#ad40fd79662b72c1effc0c2b21bf32150" title="Sets the mass of a dynamic body.">setMass()</a> does not update the inertial properties of the body, to change the inertia tensor use setMassSpaceInertiaTensor() or <a class="el" href="classp_rigid_body.html#a006c18f270a92193f26e9a89abf6276d" title="Recomputes a dynamic body&#39;s mass properties from its shapes.">updateMassFromShapes()</a>.</p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the body up automatically.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mass</em>&nbsp;</td><td>New mass value for the body. <b>Range:</b> (0,inf)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ad40fd79662b72c1effc0c2b21bf32150" title="Sets the mass of a dynamic body.">setMass()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The mass must be positive and the body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="a6070a3b1f3307550789c46d945316f76"></a><!-- doxytag: member="pRigidBody::setCMassOffsetLocalPosition" ref="a6070a3b1f3307550789c46d945316f76" args="(VxVector offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setCMassOffsetLocalPosition </td>
          <td>(</td>
          <td class="paramtype">VxVector&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The setCMassOffsetLocal*() methods set the pose of the center of mass relative to the body. </p>
<p>Methods that automatically compute the center of mass such as <a class="el" href="classp_rigid_body.html#a006c18f270a92193f26e9a89abf6276d" title="Recomputes a dynamic body&#39;s mass properties from its shapes.">updateMassFromShapes()</a> as well as computing the mass and inertia using the bodies shapes, will set this pose automatically.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Setting an unrealistic center of mass which is a long way from the body can make it difficult for the SDK to solve constraints. Perhaps leading to instability and jittering bodies.</dd></dl>
<p><b>Sleeping:</b> This call wakes the body if it is sleeping.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>vec</em>&nbsp;</td><td>Mass frame offset relative to the body frame. <b>Range:</b> position vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="a006c18f270a92193f26e9a89abf6276d"></a><!-- doxytag: member="pRigidBody::updateMassFromShapes" ref="a006c18f270a92193f26e9a89abf6276d" args="(float density, float totalMass)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pRigidBody::updateMassFromShapes </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>density</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>totalMass</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recomputes a dynamic body's mass properties from its shapes. </p>
<p>Given a constant density or total mass, the bodies mass properties can be recomputed using the shapes attached to the body. If the body has no shapes, then only the totalMass parameter can be used. If all shapes in the body are trigger shapes (non-physical), the call will fail.</p>
<p>The mass of each shape is either the shape's local density (as specified in the NxShapeDesc; default 1.0) multiplied by the shape's volume or a directly specified shape mass.</p>
<p>The inertia tensor, mass frame and center of mass will always be recomputed. If there are no shapes in the body, the mass will be totalMass, and the mass frame will be set to the center of the body.</p>
<p>If you supply a non-zero total mass, the body's mass and inertia will first be computed as above and then scaled to fit this total mass.</p>
<p>If you supply a non-zero density, the body's mass and inertia will first be computed as above and then scaled by this fbody.</p>
<p>Either totalMass or density must be non-zero.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>density</em>&nbsp;</td><td>Density scale fbody of the shapes belonging to the body. <b>Range:</b> [0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>totalMass</em>&nbsp;</td><td>Total mass of the body(or zero). <b>Range:</b> [0,inf)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ad40fd79662b72c1effc0c2b21bf32150" title="Sets the mass of a dynamic body.">setMass()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>Sleeping:</b> Does <b>NOT</b> wake the body up automatically. </dd></dl>

</div>
</div>
<a class="anchor" id="ac482b4f236cfa368704f7c802003b75f"></a><!-- doxytag: member="pRigidBody::addForce" ref="ac482b4f236cfa368704f7c802003b75f" args="(const VxVector &amp;force, ForceMode mode=FM_Force, bool wakeUp=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::addForce </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FM_Force</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeUp</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a force (or impulse) defined in the global coordinate frame to the body. </p>
<p>Methods that automatically compute the center of mass such as <a class="el" href="classp_rigid_body.html#a006c18f270a92193f26e9a89abf6276d" title="Recomputes a dynamic body&#39;s mass properties from its shapes.">updateMassFromShapes()</a> as well as computing the mass and inertia using the bodies shapes, will set this pose automatically.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/Impulse to apply defined in the global frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>).Default = <a class="el" href="group___rigid_body.html#gga82ef2c5b8d4fe771828e8cdf8582a0aca24e4195f0392e4e588de66feaff8671b">FM_Force</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeUp</em>&nbsp;</td><td>Specify if the call should wake up the body.Default = true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a15079127af14b3dd3c96d6c84ad860f0" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtPos()</a> <a class="el" href="classp_rigid_body.html#abc4363e2b26177fce66f63a6efe85553" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtLocalPos()</a> <a class="el" href="classp_rigid_body.html#a04cd52f7d438447893c2c447a05f7e25" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtPos()</a> <a class="el" href="classp_rigid_body.html#aa4260645981771a6595ce6b1df166e43" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtLocalPos()</a> <a class="el" href="classp_rigid_body.html#ac482b4f236cfa368704f7c802003b75f" title="Applies a force (or impulse) defined in the global coordinate frame to the body.">addForce()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>This will not induce a torque</b>.<br/>
 <b>Sleeping:</b> This call wakes the body if it is sleeping and the wakeup parameter is true (default). </dd></dl>

</div>
</div>
<a class="anchor" id="a15079127af14b3dd3c96d6c84ad860f0"></a><!-- doxytag: member="pRigidBody::addForceAtPos" ref="a15079127af14b3dd3c96d6c84ad860f0" args="(const VxVector &amp;force, const VxVector &amp;point, ForceMode mode=FM_Force, bool wakeUp=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::addForceAtPos </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FM_Force</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeUp</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in global coordinates, to the body. </p>
<p>Note that if the force does not act along the center of mass of the body, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the global frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point</em>&nbsp;</td><td>Position in the global frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeUp</em>&nbsp;</td><td>Specify if the call should wake up the body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> </dd>
<dd>
<a class="el" href="classp_rigid_body.html#abc4363e2b26177fce66f63a6efe85553" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtLocalPos()</a> <a class="el" href="classp_rigid_body.html#a04cd52f7d438447893c2c447a05f7e25" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtPos()</a> <a class="el" href="classp_rigid_body.html#aa4260645981771a6595ce6b1df166e43" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtLocalPos()</a> <a class="el" href="classp_rigid_body.html#ac482b4f236cfa368704f7c802003b75f" title="Applies a force (or impulse) defined in the global coordinate frame to the body.">addForce()</a> <a class="el" href="classp_rigid_body.html#ad108083a58222d1bfdd4e2eaa4a174e3" title="Applies a force (or impulse) defined in the body local coordinate frame to the body...">addLocalForce()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>This will not induce a torque</b>.<br/>
 <b>Sleeping:</b> This call wakes the body if it is sleeping and the wakeup parameter is true (default). </dd></dl>

</div>
</div>
<a class="anchor" id="abc4363e2b26177fce66f63a6efe85553"></a><!-- doxytag: member="pRigidBody::addForceAtLocalPos" ref="abc4363e2b26177fce66f63a6efe85553" args="(const VxVector &amp;force, const VxVector &amp;point, ForceMode mode=FM_Force, bool wakeUp=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::addForceAtLocalPos </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FM_Force</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeUp</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a force (or impulse) defined in the global coordinate frame, acting at a particular point in local coordinates, to the body. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Note that if the force does not act along the center of mass of the body, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.</dd></dl>
<p><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> determines if the force is to be conventional or impulsive.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the global frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point</em>&nbsp;</td><td>Position in the local frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeUp</em>&nbsp;</td><td>Specify if the call should wake up the body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> </dd>
<dd>
<a class="el" href="classp_rigid_body.html#a15079127af14b3dd3c96d6c84ad860f0" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtPos()</a> <a class="el" href="classp_rigid_body.html#a04cd52f7d438447893c2c447a05f7e25" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtPos()</a> <a class="el" href="classp_rigid_body.html#aa4260645981771a6595ce6b1df166e43" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtLocalPos()</a> <a class="el" href="classp_rigid_body.html#ac482b4f236cfa368704f7c802003b75f" title="Applies a force (or impulse) defined in the global coordinate frame to the body.">addForce()</a> <a class="el" href="classp_rigid_body.html#ad108083a58222d1bfdd4e2eaa4a174e3" title="Applies a force (or impulse) defined in the body local coordinate frame to the body...">addLocalForce()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>This will not induce a torque</b>.<br/>
 <b>Sleeping:</b> This call wakes the body if it is sleeping and the wakeup parameter is true (default). </dd></dl>

</div>
</div>
<a class="anchor" id="ad108083a58222d1bfdd4e2eaa4a174e3"></a><!-- doxytag: member="pRigidBody::addLocalForce" ref="ad108083a58222d1bfdd4e2eaa4a174e3" args="(const VxVector &amp;force, ForceMode mode=FM_Force, bool wakeUp=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::addLocalForce </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FM_Force</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeUp</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a force (or impulse) defined in the body local coordinate frame to the body. </p>
<p><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> determines if the force is to be conventional or impulsive.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/Impulse to apply defined in the local frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeUp</em>&nbsp;</td><td>Specify if the call should wake up the body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> </dd>
<dd>
<a class="el" href="classp_rigid_body.html#a15079127af14b3dd3c96d6c84ad860f0" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtPos()</a> <a class="el" href="classp_rigid_body.html#abc4363e2b26177fce66f63a6efe85553" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtLocalPos()</a> <a class="el" href="classp_rigid_body.html#a04cd52f7d438447893c2c447a05f7e25" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtPos()</a> <a class="el" href="classp_rigid_body.html#aa4260645981771a6595ce6b1df166e43" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtLocalPos()</a> <a class="el" href="classp_rigid_body.html#ac482b4f236cfa368704f7c802003b75f" title="Applies a force (or impulse) defined in the global coordinate frame to the body.">addForce()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>This will not induce a torque</b>.<br/>
 <b>Sleeping:</b> This call wakes the body if it is sleeping and the wakeup parameter is true (default). </dd></dl>

</div>
</div>
<a class="anchor" id="a04cd52f7d438447893c2c447a05f7e25"></a><!-- doxytag: member="pRigidBody::addLocalForceAtPos" ref="a04cd52f7d438447893c2c447a05f7e25" args="(const VxVector &amp;force, const VxVector &amp;point, ForceMode mode=FM_Force, bool wakeUp=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::addLocalForceAtPos </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FM_Force</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeUp</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a force (or impulse) defined in the body local coordinate frame, acting at a particular point in global coordinates, to the body. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Note that if the force does not act along the center of mass of the body, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.</dd></dl>
<p><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> determines if the force is to be conventional or impulsive.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the local frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point</em>&nbsp;</td><td>Position in the global frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeUp</em>&nbsp;</td><td>Specify if the call should wake up the body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> </dd>
<dd>
<a class="el" href="classp_rigid_body.html#a15079127af14b3dd3c96d6c84ad860f0" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtPos()</a> <a class="el" href="classp_rigid_body.html#abc4363e2b26177fce66f63a6efe85553" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtLocalPos()</a> <a class="el" href="classp_rigid_body.html#a04cd52f7d438447893c2c447a05f7e25" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtPos()</a> <a class="el" href="classp_rigid_body.html#aa4260645981771a6595ce6b1df166e43" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtLocalPos()</a> <a class="el" href="classp_rigid_body.html#ac482b4f236cfa368704f7c802003b75f" title="Applies a force (or impulse) defined in the global coordinate frame to the body.">addForce()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>This will not induce a torque</b>.<br/>
 <b>Sleeping:</b> This call wakes the body if it is sleeping and the wakeup parameter is true (default). </dd></dl>

</div>
</div>
<a class="anchor" id="aa4260645981771a6595ce6b1df166e43"></a><!-- doxytag: member="pRigidBody::addLocalForceAtLocalPos" ref="aa4260645981771a6595ce6b1df166e43" args="(const VxVector &amp;force, const VxVector &amp;point, ForceMode mode=FM_Force, bool wakeUp=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::addLocalForceAtLocalPos </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>force</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FM_Force</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeUp</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies a force (or impulse) defined in the body local coordinate frame, acting at a particular point in local coordinates, to the body. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Note that if the force does not act along the center of mass of the body, this will also add the corresponding torque. Because forces are reset at the end of every timestep, you can maintain a total external force on an object by calling this once every frame.</dd></dl>
<p><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> determines if the force is to be conventional or impulsive.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>force</em>&nbsp;</td><td>Force/impulse to add, defined in the local frame. <b>Range:</b> force vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point</em>&nbsp;</td><td>Position in the local frame to add the force at. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeUp</em>&nbsp;</td><td>Specify if the call should wake up the body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> </dd>
<dd>
<a class="el" href="classp_rigid_body.html#a15079127af14b3dd3c96d6c84ad860f0" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtPos()</a> <a class="el" href="classp_rigid_body.html#abc4363e2b26177fce66f63a6efe85553" title="Applies a force (or impulse) defined in the global coordinate frame, acting at a...">addForceAtLocalPos()</a> <a class="el" href="classp_rigid_body.html#a04cd52f7d438447893c2c447a05f7e25" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtPos()</a> <a class="el" href="classp_rigid_body.html#aa4260645981771a6595ce6b1df166e43" title="Applies a force (or impulse) defined in the body local coordinate frame, acting at...">addLocalForceAtLocalPos()</a> <a class="el" href="classp_rigid_body.html#ac482b4f236cfa368704f7c802003b75f" title="Applies a force (or impulse) defined in the global coordinate frame to the body.">addForce()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>This will not induce a torque</b>.<br/>
 <b>Sleeping:</b> This call wakes the body if it is sleeping and the wakeup parameter is true (default). </dd></dl>

</div>
</div>
<a class="anchor" id="a56abbb3058367ecd8d4e7a81edd4a94f"></a><!-- doxytag: member="pRigidBody::addTorque" ref="a56abbb3058367ecd8d4e7a81edd4a94f" args="(const VxVector &amp;torque, ForceMode mode=FM_Force, bool wakeUp=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::addTorque </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>torque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FM_Force</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeUp</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies an impulsive torque defined in the global coordinate frame to the body. </p>
<p><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> determines if the force is to be conventional or impulsive.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>torque</em>&nbsp;</td><td>Torque to apply defined in the global frame. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeUp</em>&nbsp;</td><td>Specify if the call should wake up the body.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a6a95f5df5d9f89e5eaed2520cb0801c7" title="Applies an impulsive torque defined in the body local coordinate frame to the body...">addLocalTorque()</a> <a class="el" href="classp_rigid_body.html#ac482b4f236cfa368704f7c802003b75f" title="Applies a force (or impulse) defined in the global coordinate frame to the body.">addForce()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>This will not induce a torque</b>.<br/>
 <b>Sleeping:</b> This call wakes the body if it is sleeping and the wakeup parameter is true (default). </dd></dl>

</div>
</div>
<a class="anchor" id="a6a95f5df5d9f89e5eaed2520cb0801c7"></a><!-- doxytag: member="pRigidBody::addLocalTorque" ref="a6a95f5df5d9f89e5eaed2520cb0801c7" args="(const VxVector &amp;torque, ForceMode mode=FM_Force, bool wakeUp=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::addLocalTorque </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>torque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>FM_Force</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>wakeUp</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies an impulsive torque defined in the body local coordinate frame to the body. </p>
<p><a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a> determines if the force is to be conventional or impulsive.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>torque</em>&nbsp;</td><td>Torque to apply defined in the local frame. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>The mode to use when applying the force/impulse(see <a class="el" href="group___rigid_body.html#ga82ef2c5b8d4fe771828e8cdf8582a0ac">ForceMode</a>). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeUp</em>&nbsp;</td><td>Specify if the call should wake up the body. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a6a95f5df5d9f89e5eaed2520cb0801c7" title="Applies an impulsive torque defined in the body local coordinate frame to the body...">addLocalTorque()</a> <a class="el" href="classp_rigid_body.html#ac482b4f236cfa368704f7c802003b75f" title="Applies a force (or impulse) defined in the global coordinate frame to the body.">addForce()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>This will not induce a torque</b>.<br/>
 <b>Sleeping:</b> This call wakes the body if it is sleeping and the wakeup parameter is true (default). </dd></dl>

</div>
</div>
<a class="anchor" id="a50e446c8f5e2357025e7627eb66e7349"></a><!-- doxytag: member="pRigidBody::setAngularMomentum" ref="a50e446c8f5e2357025e7627eb66e7349" args="(const VxVector &amp;angMoment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setAngularMomentum </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>angMoment</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the angular momentum of the body. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Note that if you continuously set the linear momentum of an body yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of a body.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angMoment</em>&nbsp;</td><td>New angular momentum. <b>Range:</b> angular momentum vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a868460d2e91c1785911f4f2e008eaa29" title="Retrieves the angular momentum of an body.">getAngularMomentum()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ac13b3422ceb584a984c4083c50e7028c"></a><!-- doxytag: member="pRigidBody::setLinearMomentum" ref="ac13b3422ceb584a984c4083c50e7028c" args="(const VxVector &amp;linMoment)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setLinearMomentum </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>linMoment</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the linear momentum of the body. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Note that if you continuously set the linear momentum of an body yourself, forces such as gravity or friction will not be able to manifest themselves, because forces directly influence only the velocity/momentum of a body.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linMoment</em>&nbsp;</td><td>New linear momentum. <b>Range:</b> momentum vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a6665707a48b4a798cb2128b279fd802e" title="Retrieves the linear momentum of an body.">getLinearMomentum()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a868460d2e91c1785911f4f2e008eaa29"></a><!-- doxytag: member="pRigidBody::getAngularMomentum" ref="a868460d2e91c1785911f4f2e008eaa29" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VxVector pRigidBody::getAngularMomentum </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the angular momentum of an body. </p>
<p>The angular momentum is equal to the angular velocity times the global space inertia tensor.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The angular momentum for the body.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ac13b3422ceb584a984c4083c50e7028c" title="Sets the linear momentum of the body.">setLinearMomentum()</a> <a class="el" href="classp_rigid_body.html#a868460d2e91c1785911f4f2e008eaa29" title="Retrieves the angular momentum of an body.">getAngularMomentum()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a6665707a48b4a798cb2128b279fd802e"></a><!-- doxytag: member="pRigidBody::getLinearMomentum" ref="a6665707a48b4a798cb2128b279fd802e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VxVector pRigidBody::getLinearMomentum </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the linear momentum of an body. </p>
<p>The momentum is equal to the velocity times the mass.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The linear momentum for the body.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ac13b3422ceb584a984c4083c50e7028c" title="Sets the linear momentum of the body.">setLinearMomentum()</a> <a class="el" href="classp_rigid_body.html#a868460d2e91c1785911f4f2e008eaa29" title="Retrieves the angular momentum of an body.">getAngularMomentum()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="adcfdf047b1e5ca33927431c6a066ff1d"></a><!-- doxytag: member="pRigidBody::setPosition" ref="adcfdf047b1e5ca33927431c6a066ff1d" args="(const VxVector &amp;pos, CK3dEntity *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setPosition </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CK3dEntity *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a dynamic body's position in the world. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos</em>&nbsp;</td><td>New position for the bodies frame relative to the global frame. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Reference object specifing a subshape for the case the body is a compound object. Must be a mesh or an 3D-entity. Default = Null</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>getPosition() </dd></dl>

</div>
</div>
<a class="anchor" id="af0f06d6da8310eb62d4ad33fb9f14258"></a><!-- doxytag: member="pRigidBody::setRotation" ref="af0f06d6da8310eb62d4ad33fb9f14258" args="(const VxQuaternion &amp;rot, CK3dEntity *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setRotation </td>
          <td>(</td>
          <td class="paramtype">const VxQuaternion &amp;&nbsp;</td>
          <td class="paramname"> <em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CK3dEntity *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a dynamic body's orientation in the world. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rot</em>&nbsp;</td><td>New orientation for the bodies frame. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Reference object specifying a sub shape for the case the body is a compound object. Must be a mesh or an 3D-entity. Default = Null</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a6665707a48b4a798cb2128b279fd802e" title="Retrieves the linear momentum of an body.">getLinearMomentum()</a> <a class="el" href="classp_rigid_body.html#a50e446c8f5e2357025e7627eb66e7349" title="Sets the angular momentum of the body.">setAngularMomentum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2a664ddfb6ab190b63cfb0eed7089ce5"></a><!-- doxytag: member="pRigidBody::enableCollision" ref="a2a664ddfb6ab190b63cfb0eed7089ce5" args="(bool enable, CK3dEntity *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::enableCollision </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CK3dEntity *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables/disable collision detection. I.e. the body will not collide with other objects. Please note that you might need to wake the body up if it is sleeping, this depends on the result you wish to get when using this flag. (If a body is asleep it will not start to fall through objects unless you activate it). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable.</em>&nbsp;</td><td>Flag to determining collisions response for the body. to collision detect with each other. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Reference object specifing a subshape for the case the body is a compound object. Must be a mesh or an 3D-entity. Default = Null</td></tr>
  </table>
  </dd>
</dl>
<p>: Also excludes the body from overlap tests!</p>
<dl class="see"><dt><b>See also:</b></dt><dd>isCollisionEnabled()</dd></dl>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the associated body up automatically. </p>

</div>
</div>
<a class="anchor" id="a4f55366c796d18a6b1ebfc1b5051d912"></a><!-- doxytag: member="pRigidBody::setCollisionsGroup" ref="a4f55366c796d18a6b1ebfc1b5051d912" args="(int index, CK3dEntity *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setCollisionsGroup </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CK3dEntity *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the collisions group the body belongs too. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>The new group index. Default group is 0. Maximum possible group is 31.Collision groups are sets of shapes which may or may not be set to collision detect with each other. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Sub shape reference. Must be a mesh or an 3D-entity. Default = Null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>If you pass a sub shape reference then its only setting the group on the sub shape and not for all sub shapes.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a6503353b83ea152c55cea6bccfd51dd7" title="Retrieves the collisions group which this body or a sub shape of it is part of.">getCollisionsGroup()</a> </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 <b>Sleeping:</b> Does <b>NOT</b> wake the associated body up automatically. </dd></dl>

</div>
</div>
<a class="anchor" id="a6503353b83ea152c55cea6bccfd51dd7"></a><!-- doxytag: member="pRigidBody::getCollisionsGroup" ref="a6503353b83ea152c55cea6bccfd51dd7" args="(CK3dEntity *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pRigidBody::getCollisionsGroup </td>
          <td>(</td>
          <td class="paramtype">CK3dEntity *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the collisions group which this body or a sub shape of it is part of. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Sub shape reference. Must be a mesh or an 3D-entity. Default = Null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The collision group this body or sub shape belongs to.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a4f55366c796d18a6b1ebfc1b5051d912" title="Sets the collisions group the body belongs too.">setCollisionsGroup()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="abc939d1610cf66b1cc71556d93317a53"></a><!-- doxytag: member="pRigidBody::setBoxDimensions" ref="abc939d1610cf66b1cc71556d93317a53" args="(const VxVector &amp;dimension, CKBeObject *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setBoxDimensions </td>
          <td>(</td>
          <td class="paramtype">const VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKBeObject *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the box dimension of the initial shape or a sub shape. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dimension</em>&nbsp;</td><td>New dimension. <b>Range:</b> dimension vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Sub shape reference. Must be a mesh or an 3D-entity. Default = Null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a3e61f7a180d478c3486e0f5db24b0ffc" title="Retrieves the box dimension of the initial shape or sub shape.">getBoxDimensions()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The call doesnt updates the bodies mass.Use <a class="el" href="classp_rigid_body.html#a006c18f270a92193f26e9a89abf6276d" title="Recomputes a dynamic body&#39;s mass properties from its shapes.">updateMassFromShapes()</a><br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a3e61f7a180d478c3486e0f5db24b0ffc"></a><!-- doxytag: member="pRigidBody::getBoxDimensions" ref="a3e61f7a180d478c3486e0f5db24b0ffc" args="(CKBeObject *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VxVector pRigidBody::getBoxDimensions </td>
          <td>(</td>
          <td class="paramtype">CKBeObject *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the box dimension of the initial shape or sub shape. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Sub shape reference. Must be a mesh or an 3D-entity. Default = Null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#abc939d1610cf66b1cc71556d93317a53" title="Updates the box dimension of the initial shape or a sub shape.">setBoxDimensions()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7f9ade29e66eab080827a61214542d0b"></a><!-- doxytag: member="pRigidBody::setSphereRadius" ref="a7f9ade29e66eab080827a61214542d0b" args="(float radius, CKBeObject *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setSphereRadius </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKBeObject *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the radius of the initial shape or a sub shape. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>radius</em>&nbsp;</td><td>New radius. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Sub shape reference. Must be a mesh or an 3D-entity. Default = Null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ad8ac70192f2e743dc598abb492ade6df" title="Retrieves the radius of the initial shape or sub shape.">getSphereRadius()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The call doest updates the bodies mass.Use <a class="el" href="classp_rigid_body.html#a006c18f270a92193f26e9a89abf6276d" title="Recomputes a dynamic body&#39;s mass properties from its shapes.">updateMassFromShapes()</a><br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="ad8ac70192f2e743dc598abb492ade6df"></a><!-- doxytag: member="pRigidBody::getSphereRadius" ref="ad8ac70192f2e743dc598abb492ade6df" args="(CKBeObject *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pRigidBody::getSphereRadius </td>
          <td>(</td>
          <td class="paramtype">CKBeObject *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the radius of the initial shape or sub shape. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Sub shape reference. Must be a mesh or an 3D-entity. Default = Null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a7f9ade29e66eab080827a61214542d0b" title="Updates the radius of the initial shape or a sub shape.">setSphereRadius()</a> . </dd></dl>

</div>
</div>
<a class="anchor" id="af613fc26ae60a10f8eec06c21792bfc4"></a><!-- doxytag: member="pRigidBody::setCapsuleDimensions" ref="af613fc26ae60a10f8eec06c21792bfc4" args="(float radius, float length, CKBeObject *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setCapsuleDimensions </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKBeObject *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the capsule parameter of the initial shape or a sub shape. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>radius</em>&nbsp;</td><td>New radius. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>New length. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Sub shape reference. Must be a mesh or an 3D-entity. Default = Null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#afcbabe0545196c9d6a5f74ab9d89829b" title="Retrieves the capsule parameters of the initial shape or sub shape.">getCapsuleDimensions()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The call doesnt updates the bodies mass.Use <a class="el" href="classp_rigid_body.html#a006c18f270a92193f26e9a89abf6276d" title="Recomputes a dynamic body&#39;s mass properties from its shapes.">updateMassFromShapes()</a><br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="afcbabe0545196c9d6a5f74ab9d89829b"></a><!-- doxytag: member="pRigidBody::getCapsuleDimensions" ref="afcbabe0545196c9d6a5f74ab9d89829b" args="(float &amp;radius, float &amp;length, CKBeObject *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::getCapsuleDimensions </td>
          <td>(</td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKBeObject *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the capsule parameters of the initial shape or sub shape. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>radius</em>&nbsp;</td><td>The radius of the capsule. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The length of the capsule. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Sub shape reference. Must be a mesh or an 3D-entity. Default = Null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#af613fc26ae60a10f8eec06c21792bfc4" title="Updates the capsule parameter of the initial shape or a sub shape.">setCapsuleDimensions()</a> . </dd></dl>

</div>
</div>
<a class="anchor" id="aed769a9e939a44c34eb58d6f26c311ee"></a><!-- doxytag: member="pRigidBody::getShapeType" ref="aed769a9e939a44c34eb58d6f26c311ee" args="(CKBeObject *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___rigid_body.html#gae3a18d6e3dcbff2fbc246b48960a94d9">HullType</a> pRigidBody::getShapeType </td>
          <td>(</td>
          <td class="paramtype">CKBeObject *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the hull type of the initial shape or sub shape. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The hull type. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Sub shape reference. Default = Null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a881a845ee955bfa165da8fbe4572ef35"></a><!-- doxytag: member="pRigidBody::getSkinWidth" ref="a881a845ee955bfa165da8fbe4572ef35" args="(CKBeObject *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pRigidBody::getSkinWidth </td>
          <td>(</td>
          <td class="paramtype">CKBeObject *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the skin width of the initial shape or a sub shape. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The skin with. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Sub shape reference. Must be a mesh or an 3D-entity. Default = Null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a3ae1d99f2f8466512eba4ed7e5f52503" title="Updates the skin width of the initial shape or a sub shape.">setSkinWidth()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3ae1d99f2f8466512eba4ed7e5f52503"></a><!-- doxytag: member="pRigidBody::setSkinWidth" ref="a3ae1d99f2f8466512eba4ed7e5f52503" args="(const float skinWidth, CKBeObject *subShapeReference=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setSkinWidth </td>
          <td>(</td>
          <td class="paramtype">const float&nbsp;</td>
          <td class="paramname"> <em>skinWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKBeObject *&nbsp;</td>
          <td class="paramname"> <em>subShapeReference</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Updates the skin width of the initial shape or a sub shape. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>skinWidth</em>&nbsp;</td><td>The new skin width. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>subShapeReference</em>&nbsp;</td><td>Sub shape reference. Must be a mesh or an 3D-entity. Default = Null.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a3ae1d99f2f8466512eba4ed7e5f52503" title="Updates the skin width of the initial shape or a sub shape.">setSkinWidth()</a> </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd><b>Sleeping:</b> Does <b>NOT</b> wake the associated body up automatically. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2af58f48c0f1b2b14da6138b62681e3"></a><!-- doxytag: member="pRigidBody::setSolverIterationCount" ref="aa2af58f48c0f1b2b14da6138b62681e3" args="(int count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setSolverIterationCount </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>count</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The solver iteration count determines how accurately joints and contacts are resolved. <br/>
 If you are having trouble with jointed bodies oscillating and behaving erratically, then setting a higher solver iteration count may improve their stability. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>Number of iterations the solver should perform for this body. <br/>
</p>
<ul>
<li><b>Range:</b> [1,255] </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3d726f61561e40fd3baf20d1d2463030"></a><!-- doxytag: member="pRigidBody::setDominanceGroup" ref="a3d726f61561e40fd3baf20d1d2463030" args="(int dominanceGroup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setDominanceGroup </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dominanceGroup</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assigns dynamic bodies a dominance group identifier.<br/>
. </p>
<p>The dominance group is a 5 bit group identifier (legal range from 0 to 31).</p>
<p>The pWorld::setDominanceGroupPair() lets you set certain behaviors for pairs of dominance groups. By default every body is created in group 0. Static bodies must stay in group 0; thus you can only call this on dynamic bodys.</p>
<p><b>Sleeping:</b> Changing the dominance group does <b>NOT</b> wake the body up automatically.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a26f85f61fde9a083fed8d7bf06bf2a86" title="Retrieves the value set with setDominanceGroup(). .">getDominanceGroup()</a> NxScene::setDominanceGroupPair() </dd></dl>

</div>
</div>
<a class="anchor" id="a26f85f61fde9a083fed8d7bf06bf2a86"></a><!-- doxytag: member="pRigidBody::getDominanceGroup" ref="a26f85f61fde9a083fed8d7bf06bf2a86" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pRigidBody::getDominanceGroup </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the value set with <a class="el" href="classp_rigid_body.html#a3d726f61561e40fd3baf20d1d2463030" title="Assigns dynamic bodies a dominance group identifier. .">setDominanceGroup()</a>.<br/>
. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The dominance group of this body.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a3d726f61561e40fd3baf20d1d2463030" title="Assigns dynamic bodies a dominance group identifier. .">setDominanceGroup()</a> pWorld::setDominanceGroupPair() </dd></dl>

</div>
</div>
<a class="anchor" id="a02b9c7d5b91381ebfa2ba60751a4d3f4"></a><!-- doxytag: member="pRigidBody::getSleepLinearVelocity" ref="a02b9c7d5b91381ebfa2ba60751a4d3f4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pRigidBody::getSleepLinearVelocity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the linear velocity below which an body may go to sleep.<br/>
. </p>
<p>Bodies whose linear velocity is above this threshold will not be put to sleep.</p>
<p>The body must be dynamic.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ab88f1af6b55b5ae2e01e7de5938ed68c" title="Checks whether the body is in a sleeping state.">isSleeping</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The threshold linear velocity for sleeping.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>isGroupSleeping() <a class="el" href="classp_rigid_body.html#ab88f1af6b55b5ae2e01e7de5938ed68c" title="Checks whether the body is in a sleeping state.">isSleeping()</a> <a class="el" href="classp_rigid_body.html#a02b9c7d5b91381ebfa2ba60751a4d3f4" title="Returns the linear velocity below which an body may go to sleep. .">getSleepLinearVelocity()</a> <a class="el" href="classp_rigid_body.html#af340cba727c9ef5ab0aa458f9e63ef1d" title="Returns the angular velocity below which an body may go to sleep. .">getSleepAngularVelocity()</a> <a class="el" href="classp_rigid_body.html#a0194f95349781d1fa4c1a99fce612613" title="Wakes up the body if it is sleeping.">wakeUp()</a> putToSleep() <a class="el" href="classp_rigid_body.html#ae3fc1b6670fc28fbc727d73278c88341" title="Sets the linear velocity below which an body may go to sleep. .">setSleepLinearVelocity()</a> <a class="el" href="classp_rigid_body.html#aff87a911b4ea2235ce32336e2b51cfc2" title="Sets the energy threshold below which an body may go to sleep. .">setSleepEnergyThreshold()</a> <a class="el" href="classp_rigid_body.html#a4f7277b57cad3cefcb71a4ef7f801137" title="Returns the energy below which an body may go to sleep. .">getSleepEnergyThreshold()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae3fc1b6670fc28fbc727d73278c88341"></a><!-- doxytag: member="pRigidBody::setSleepLinearVelocity" ref="ae3fc1b6670fc28fbc727d73278c88341" args="(float threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setSleepLinearVelocity </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the linear velocity below which an body may go to sleep.<br/>
. </p>
<p>Bodies whose linear velocity is above this threshold will not be put to sleep.</p>
<p>If the threshold value is negative, the velocity threshold is set using the NxPhysicsSDK's NX_DEFAULT_SLEEP_LIN_VEL_SQUARED parameter.</p>
<p>Setting the sleep angular/linear velocity only makes sense when the NX_BF_ENERGY_SLEEP_TEST is not set. In version 2.5 and later a new method is used by default which uses the kinetic energy of the body to control sleeping.</p>
<p>The body must be dynamic.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Linear velocity below which an body may sleep. <b>Range:</b> (0,inf]</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>isGroupSleeping() <a class="el" href="classp_rigid_body.html#ab88f1af6b55b5ae2e01e7de5938ed68c" title="Checks whether the body is in a sleeping state.">isSleeping()</a> <a class="el" href="classp_rigid_body.html#a02b9c7d5b91381ebfa2ba60751a4d3f4" title="Returns the linear velocity below which an body may go to sleep. .">getSleepLinearVelocity()</a> <a class="el" href="classp_rigid_body.html#af340cba727c9ef5ab0aa458f9e63ef1d" title="Returns the angular velocity below which an body may go to sleep. .">getSleepAngularVelocity()</a> <a class="el" href="classp_rigid_body.html#a0194f95349781d1fa4c1a99fce612613" title="Wakes up the body if it is sleeping.">wakeUp()</a> putToSleep() <a class="el" href="classp_rigid_body.html#aff87a911b4ea2235ce32336e2b51cfc2" title="Sets the energy threshold below which an body may go to sleep. .">setSleepEnergyThreshold()</a> <a class="el" href="classp_rigid_body.html#a4f7277b57cad3cefcb71a4ef7f801137" title="Returns the energy below which an body may go to sleep. .">getSleepEnergyThreshold()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af340cba727c9ef5ab0aa458f9e63ef1d"></a><!-- doxytag: member="pRigidBody::getSleepAngularVelocity" ref="af340cba727c9ef5ab0aa458f9e63ef1d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pRigidBody::getSleepAngularVelocity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the angular velocity below which an body may go to sleep.<br/>
. </p>
<p>Bodies whose angular velocity is above this threshold will not be put to sleep.</p>
<p>The body must be dynamic.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The threshold angular velocity for sleeping.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>isGroupSleeping() <a class="el" href="classp_rigid_body.html#ab88f1af6b55b5ae2e01e7de5938ed68c" title="Checks whether the body is in a sleeping state.">isSleeping()</a> <a class="el" href="classp_rigid_body.html#a02b9c7d5b91381ebfa2ba60751a4d3f4" title="Returns the linear velocity below which an body may go to sleep. .">getSleepLinearVelocity()</a> <a class="el" href="classp_rigid_body.html#af340cba727c9ef5ab0aa458f9e63ef1d" title="Returns the angular velocity below which an body may go to sleep. .">getSleepAngularVelocity()</a> <a class="el" href="classp_rigid_body.html#a0194f95349781d1fa4c1a99fce612613" title="Wakes up the body if it is sleeping.">wakeUp()</a> putToSleep() <a class="el" href="classp_rigid_body.html#ac4ba53cdf6c539fbbbe79b11dd71feb6" title="Sets the angular velocity below which an body may go to sleep. .">setSleepAngularVelocity()</a> <a class="el" href="classp_rigid_body.html#aff87a911b4ea2235ce32336e2b51cfc2" title="Sets the energy threshold below which an body may go to sleep. .">setSleepEnergyThreshold()</a> <a class="el" href="classp_rigid_body.html#a4f7277b57cad3cefcb71a4ef7f801137" title="Returns the energy below which an body may go to sleep. .">getSleepEnergyThreshold()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac4ba53cdf6c539fbbbe79b11dd71feb6"></a><!-- doxytag: member="pRigidBody::setSleepAngularVelocity" ref="ac4ba53cdf6c539fbbbe79b11dd71feb6" args="(float threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setSleepAngularVelocity </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the angular velocity below which an body may go to sleep.<br/>
. </p>
<p>Bodies whose angular velocity is above this threshold will not be put to sleep.</p>
<p>If the threshold value is negative, the velocity threshold is set using the NxPhysicsSDK's NX_DEFAULT_SLEEP_LIN_VEL_SQUARED parameter.</p>
<p>Setting the sleep angular/linear velocity only makes sense when the NX_BF_ENERGY_SLEEP_TEST is not set. In version 2.5 and later a new method is used by default which uses the kinetic energy of the body to control sleeping.</p>
<p>The body must be dynamic.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Angular velocity below which an body may go to sleep.</p>
<ul>
<li><b>Range:</b> (0,inf]</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>isGroupSleeping() <a class="el" href="classp_rigid_body.html#ab88f1af6b55b5ae2e01e7de5938ed68c" title="Checks whether the body is in a sleeping state.">isSleeping()</a> <a class="el" href="classp_rigid_body.html#a02b9c7d5b91381ebfa2ba60751a4d3f4" title="Returns the linear velocity below which an body may go to sleep. .">getSleepLinearVelocity()</a> <a class="el" href="classp_rigid_body.html#af340cba727c9ef5ab0aa458f9e63ef1d" title="Returns the angular velocity below which an body may go to sleep. .">getSleepAngularVelocity()</a> <a class="el" href="classp_rigid_body.html#a0194f95349781d1fa4c1a99fce612613" title="Wakes up the body if it is sleeping.">wakeUp()</a> putToSleep() <a class="el" href="classp_rigid_body.html#ae3fc1b6670fc28fbc727d73278c88341" title="Sets the linear velocity below which an body may go to sleep. .">setSleepLinearVelocity()</a> <a class="el" href="classp_rigid_body.html#aff87a911b4ea2235ce32336e2b51cfc2" title="Sets the energy threshold below which an body may go to sleep. .">setSleepEnergyThreshold()</a> <a class="el" href="classp_rigid_body.html#a4f7277b57cad3cefcb71a4ef7f801137" title="Returns the energy below which an body may go to sleep. .">getSleepEnergyThreshold()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aff87a911b4ea2235ce32336e2b51cfc2"></a><!-- doxytag: member="pRigidBody::setSleepEnergyThreshold" ref="aff87a911b4ea2235ce32336e2b51cfc2" args="(float threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setSleepEnergyThreshold </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the energy threshold below which an body may go to sleep.<br/>
. </p>
<p>Bodies whose kinematic energy is above this threshold will not be put to sleep.</p>
<p>If the threshold value is negative, the velocity threshold is set using the NxPhysicsSDK's NX_DEFAULT_SLEEP_ENERGY parameter.</p>
<p>Setting the sleep energy threshold only makes sense when the NX_BF_ENERGY_SLEEP_TEST is set. There are also other types of sleeping that uses the linear and angular velocities directly instead of the energy.</p>
<p>The body must be dynamic.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Energy below which an actor may go to sleep. <br/>
</p>
<ul>
<li><b>Range:</b> (0,inf]</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd>isGroupSleeping() <a class="el" href="classp_rigid_body.html#ab88f1af6b55b5ae2e01e7de5938ed68c" title="Checks whether the body is in a sleeping state.">isSleeping()</a> <a class="el" href="classp_rigid_body.html#a4f7277b57cad3cefcb71a4ef7f801137" title="Returns the energy below which an body may go to sleep. .">getSleepEnergyThreshold()</a> <a class="el" href="classp_rigid_body.html#a02b9c7d5b91381ebfa2ba60751a4d3f4" title="Returns the linear velocity below which an body may go to sleep. .">getSleepLinearVelocity()</a> <a class="el" href="classp_rigid_body.html#af340cba727c9ef5ab0aa458f9e63ef1d" title="Returns the angular velocity below which an body may go to sleep. .">getSleepAngularVelocity()</a> <a class="el" href="classp_rigid_body.html#a0194f95349781d1fa4c1a99fce612613" title="Wakes up the body if it is sleeping.">wakeUp()</a> putToSleep() <a class="el" href="classp_rigid_body.html#ae3fc1b6670fc28fbc727d73278c88341" title="Sets the linear velocity below which an body may go to sleep. .">setSleepLinearVelocity()</a> <a class="el" href="classp_rigid_body.html#ac4ba53cdf6c539fbbbe79b11dd71feb6" title="Sets the angular velocity below which an body may go to sleep. .">setSleepAngularVelocity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f7277b57cad3cefcb71a4ef7f801137"></a><!-- doxytag: member="pRigidBody::getSleepEnergyThreshold" ref="a4f7277b57cad3cefcb71a4ef7f801137" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pRigidBody::getSleepEnergyThreshold </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the energy below which an body may go to sleep.<br/>
. </p>
<p>Bodies whose energy is above this threshold will not be put to sleep.</p>
<p>The body must be dynamic.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The energy threshold for sleeping.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>isGroupSleeping() <a class="el" href="classp_rigid_body.html#ab88f1af6b55b5ae2e01e7de5938ed68c" title="Checks whether the body is in a sleeping state.">isSleeping()</a> <a class="el" href="classp_rigid_body.html#a02b9c7d5b91381ebfa2ba60751a4d3f4" title="Returns the linear velocity below which an body may go to sleep. .">getSleepLinearVelocity()</a> <a class="el" href="classp_rigid_body.html#af340cba727c9ef5ab0aa458f9e63ef1d" title="Returns the angular velocity below which an body may go to sleep. .">getSleepAngularVelocity()</a> <a class="el" href="classp_rigid_body.html#a0194f95349781d1fa4c1a99fce612613" title="Wakes up the body if it is sleeping.">wakeUp()</a> putToSleep() <a class="el" href="classp_rigid_body.html#ac4ba53cdf6c539fbbbe79b11dd71feb6" title="Sets the angular velocity below which an body may go to sleep. .">setSleepAngularVelocity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac2f207318511894b2f00badc13f61387"></a><!-- doxytag: member="pRigidBody::getLinearDamping" ref="ac2f207318511894b2f00badc13f61387" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pRigidBody::getLinearDamping </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the linear damping coefficient.<br/>
. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The linear damping coefficient associated with this body.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#abc2a65fc7cf009e0c5968141b795fdd8" title="Retrieves the angular damping coefficient. .">getAngularDamping()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="abc2a65fc7cf009e0c5968141b795fdd8"></a><!-- doxytag: member="pRigidBody::getAngularDamping" ref="abc2a65fc7cf009e0c5968141b795fdd8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float pRigidBody::getAngularDamping </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the angular damping coefficient.<br/>
. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The angular damping coefficient associated with this body.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a2ccb6e3bbfda60f37497109db6a36c96" title="Sets the angular damping coefficient. .">setAngularDamping()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4bda541734ab40c7fff21e25c65ff0c"></a><!-- doxytag: member="pRigidBody::setLinearDamping" ref="ab4bda541734ab40c7fff21e25c65ff0c" args="(float linDamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setLinearDamping </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>linDamp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the linear damping coefficient.<br/>
. </p>
<p>Zero represents no damping. The damping coefficient must be nonnegative.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>linDamp</em>&nbsp;</td><td>Linear damping coefficient. <b>Range:</b> [0,inf)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ac2f207318511894b2f00badc13f61387" title="Retrieves the linear damping coefficient. .">getLinearDamping()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ccb6e3bbfda60f37497109db6a36c96"></a><!-- doxytag: member="pRigidBody::setAngularDamping" ref="a2ccb6e3bbfda60f37497109db6a36c96" args="(float angDamp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setAngularDamping </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>angDamp</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the angular damping coefficient.<br/>
. </p>
<p>Zero represents no damping. The damping coefficient must be nonnegative.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>angDamp</em>&nbsp;</td><td>Angular damping coefficient. <b>Range:</b> [0,inf)</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ac2f207318511894b2f00badc13f61387" title="Retrieves the linear damping coefficient. .">getLinearDamping()</a></dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic. </dd></dl>

</div>
</div>
<a class="anchor" id="aa306df591c61f966ba92241eb4a5948f"></a><!-- doxytag: member="pRigidBody::setKinematic" ref="aa306df591c61f966ba92241eb4a5948f" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setKinematic </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enabled</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the body to kinematic. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enabled</em>&nbsp;</td><td>Enable kinematic mode. <b>Range:</b> (0,inf) </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a1553e9d81b65564e30233fa3644673da" title="Retrieves the bodies kinematic state.">isKinematic()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1553e9d81b65564e30233fa3644673da"></a><!-- doxytag: member="pRigidBody::isKinematic" ref="a1553e9d81b65564e30233fa3644673da" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pRigidBody::isKinematic </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the bodies kinematic state. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the kinematic state. </dd></dl>

</div>
</div>
<a class="anchor" id="a427c31038418ab1043f9565359e9b008"></a><!-- doxytag: member="pRigidBody::isAffectedByGravity" ref="a427c31038418ab1043f9565359e9b008" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pRigidBody::isAffectedByGravity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether the body is affected by the worlds gravity. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Is affected by gravity. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#ac4ed1df73b118b420638dc24a7f733a1" title="Enables gravity on the body.">enableGravity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac4ed1df73b118b420638dc24a7f733a1"></a><!-- doxytag: member="pRigidBody::enableGravity" ref="ac4ed1df73b118b420638dc24a7f733a1" args="(bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::enableGravity </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>enable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables gravity on the body. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>The gravity state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a427c31038418ab1043f9565359e9b008" title="Checks whether the body is affected by the worlds gravity.">isAffectedByGravity()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab88f1af6b55b5ae2e01e7de5938ed68c"></a><!-- doxytag: member="pRigidBody::isSleeping" ref="ab88f1af6b55b5ae2e01e7de5938ed68c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pRigidBody::isSleeping </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether the body is in a sleeping state. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if sleeping. </dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a068a21eae07470cab4ae565ac5d4f62b" title="Forces the body to sleep.">setSleeping()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a068a21eae07470cab4ae565ac5d4f62b"></a><!-- doxytag: member="pRigidBody::setSleeping" ref="a068a21eae07470cab4ae565ac5d4f62b" args="(bool sleeping)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::setSleeping </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sleeping</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Forces the body to sleep. </p>
<p>The body will stay asleep until the next call to simulate, and will not wake up until then even when otherwise it would (for example a force is applied to it). It can however wake up during the next simulate call.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sleeping</em>&nbsp;</td><td>The sleeping state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a068a21eae07470cab4ae565ac5d4f62b" title="Forces the body to sleep.">setSleeping()</a> </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="a0194f95349781d1fa4c1a99fce612613"></a><!-- doxytag: member="pRigidBody::wakeUp" ref="a0194f95349781d1fa4c1a99fce612613" args="(float wakeCounterValue=pSLEEP_INTERVAL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pRigidBody::wakeUp </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>wakeCounterValue</em> = <code>pSLEEP_INTERVAL</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wakes up the body if it is sleeping. </p>
<p>The wakeCounterValue determines how long until the body is put to sleep, a value of zero means that the body is sleeping. wakeUp(0) is equivalent to NxActor::putToSleep().</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>wakeCounterValue</em>&nbsp;</td><td>New sleep counter value. Default = (20.0f*0.02f) . <b>Range:</b> [0,inf] </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_rigid_body.html#a068a21eae07470cab4ae565ac5d4f62b" title="Forces the body to sleep.">setSleeping()</a> <a class="el" href="classp_rigid_body.html#ab88f1af6b55b5ae2e01e7de5938ed68c" title="Checks whether the body is in a sleeping state.">isSleeping()</a> </dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The body must be dynamic.<br/>
 </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Feb 3 18:57:24 2010 for vtPhysX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
