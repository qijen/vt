<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>vtPhysX: pWorld Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="online.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>pWorld Class Reference</h1><!-- doxytag: class="pWorld" -->
<p>Class to maintain physical objects.  
<a href="#_details">More...</a></p>

<p><a href="classp_world-members.html">List of all members.</a></p>
<h2>Public Member Functions</h2>
<ul>
<li>void <a class="el" href="classp_world.html#ab0ca898e6b3c4be436a3fa13818911c8">step</a> (float stepsize)
<dl class="el"><dd class="mdescRight">Returns the set of shapes overlapped by the world-space capsule.  <a href="#ab0ca898e6b3c4be436a3fa13818911c8"></a><br/></dl></ul>
<h2>Collision Filtering</h2>
<p><a class="anchor" id="amgrp0655a2c2bd664ebe270898881820cd03"></a> </p>
<ul>
<li>void <a class="el" href="classp_world.html#a1b0ef1289d704dfd014e5f704182de7e">setFilterOps</a> (<a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a> op0, <a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a> op1, <a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a> op2)
<dl class="el"><dd class="mdescRight">Setups filtering operations. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.  <a href="#a1b0ef1289d704dfd014e5f704182de7e"></a><br/></dl><li>void <a class="el" href="classp_world.html#aab9935e5e1ece7f1b6cdb6e55003570e">setFilterBool</a> (bool flag)
<dl class="el"><dd class="mdescRight">Setups filtering's boolean value. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.  <a href="#aab9935e5e1ece7f1b6cdb6e55003570e"></a><br/></dl><li>void <a class="el" href="classp_world.html#abe005c4b63b45090d3f707e5a860b3f7">setFilterConstant0</a> (const <a class="el" href="classp_groups_mask.html">pGroupsMask</a> &amp;mask)
<dl class="el"><dd class="mdescRight">Setups filtering's K0 value. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.  <a href="#abe005c4b63b45090d3f707e5a860b3f7"></a><br/></dl><li>void <a class="el" href="classp_world.html#ab545ee15bc885a486cb2f293716c1611">setFilterConstant1</a> (const <a class="el" href="classp_groups_mask.html">pGroupsMask</a> &amp;mask)
<dl class="el"><dd class="mdescRight">Setups filtering's K1 value. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.  <a href="#ab545ee15bc885a486cb2f293716c1611"></a><br/></dl><li>void <a class="el" href="classp_world.html#af4dfa5c7a665397dcf73c7e8ead5042e">getFilterOps</a> (<a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a> &amp;op0, <a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a> &amp;op1, <a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a> &amp;op2) const 
<dl class="el"><dd class="mdescRight">Retrieves filtering operation. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.  <a href="#af4dfa5c7a665397dcf73c7e8ead5042e"></a><br/></dl><li>bool <a class="el" href="classp_world.html#abc0b45bf5385e213d9765e4db03aadf1">getFilterBool</a> () const 
<dl class="el"><dd class="mdescRight">Retrieves filtering's boolean value. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.  <a href="#abc0b45bf5385e213d9765e4db03aadf1"></a><br/></dl><li><a class="el" href="classp_groups_mask.html">pGroupsMask</a> <a class="el" href="classp_world.html#a921a6fa26f6596854c65629692f8a109">getFilterConstant0</a> () const 
<dl class="el"><dd class="mdescRight">Gets filtering constant K0. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.  <a href="#a921a6fa26f6596854c65629692f8a109"></a><br/></dl><li><a class="el" href="classp_groups_mask.html">pGroupsMask</a> <a class="el" href="classp_world.html#af0162940a9fc15dd4f152976ceae5012">getFilterConstant1</a> () const 
<dl class="el"><dd class="mdescRight">Gets filtering constant K1. See comments for NxGroupsMask.  <a href="#af0162940a9fc15dd4f152976ceae5012"></a><br/></dl></ul>
<h2>Raycasting</h2>
<p><a class="anchor" id="amgrp9c4182b8616c8036564209d42b94c869"></a> </p>
<ul>
<li>bool <a class="el" href="classp_world.html#ae66ea4626cb0b1b56a944e9b6f6ba2e6">raycastAnyBounds</a> (const VxRay &amp;worldRay, <a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a> shapesType, <a class="el" href="classp_groups_mask.html">pGroupsMask</a> *groupsMask=NULL, int groups=0xffffffff, float maxDist=pFLOAT_MAX)
<dl class="el"><dd class="mdescRight">Returns true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray.  <a href="#ae66ea4626cb0b1b56a944e9b6f6ba2e6"></a><br/></dl><li>bool <a class="el" href="classp_world.html#a3a25ea7422fc0c727f600a56f4c951b5">raycastAnyShape</a> (const VxRay &amp;worldRay, <a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a> shapesType, <a class="el" href="classp_groups_mask.html">pGroupsMask</a> groupsMask, CKDataArray *cache, int groups=0xffffffff, float maxDist=pFLOAT_MAX)
<dl class="el"><dd class="mdescRight">Returns true if any shape of type ShapeType is intersected by the ray.  <a href="#a3a25ea7422fc0c727f600a56f4c951b5"></a><br/></dl><li>int <a class="el" href="classp_world.html#a9a54cca619ec664ac44d5ed3cb634de6">raycastAllShapes</a> (const VxRay &amp;worldRay, <a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a> shapesType, int groups=0xffffffff, float maxDist=pFLOAT_MAX, pRaycastBit hintFlags=(pRaycastBit) 0xffffffff, const pGroupsMask *groupsMask=NULL)
<dl class="el"><dd class="mdescRight">Calls the report's hitCallback() method for all the shapes of type ShapeType intersected by the ray.  <a href="#a9a54cca619ec664ac44d5ed3cb634de6"></a><br/></dl></ul>
<h2>Overlap Testing</h2>
<p><a class="anchor" id="amgrp87ae1ef6cd7454b0a3f409cea8276b92"></a> </p>
<ul>
<li>int <a class="el" href="classp_world.html#afc72fdaa6759f68c5f322de84074bbf9">overlapSphereShapes</a> (const VxSphere &amp;worldSphere, CK3dEntity *shapeReference, <a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a> shapeType, CKGroup *shapes, int activeGroups=0xffffffff, const pGroupsMask *groupsMask=NULL, bool accurateCollision=false)
<dl class="el"><dd class="mdescRight">Returns the set of shapes overlapped by the world-space sphere.  <a href="#afc72fdaa6759f68c5f322de84074bbf9"></a><br/></dl><li>int <a class="el" href="classp_world.html#a378c2149175107725863f669b5473c1c">overlapAABBShapes</a> (const VxBbox &amp;worldBounds, CK3dEntity *shapeReference, <a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a> shapeType, CKGroup *shapes, int activeGroups=0xffffffff, const pGroupsMask *groupsMask=NULL, bool accurateCollision=false)
<dl class="el"><dd class="mdescRight">Returns the set of shapes overlapped by the world-space AABB.  <a href="#a378c2149175107725863f669b5473c1c"></a><br/></dl><li>int <a class="el" href="classp_world.html#a73939bc30803a597084c7139ebd1f678">overlapOBBShapes</a> (const VxBbox &amp;worldBox, CK3dEntity *shapeReference, <a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a> shapeType, CKGroup *shapes, int activeGroups=0xffffffff, const pGroupsMask *groupsMask=NULL, bool accurateCollision=false)
<dl class="el"><dd class="mdescRight">Returns the set of shapes overlapped by the world-space OBB.  <a href="#a73939bc30803a597084c7139ebd1f678"></a><br/></dl></ul>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Class to maintain physical objects. </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1b0ef1289d704dfd014e5f704182de7e"></a><!-- doxytag: member="pWorld::setFilterOps" ref="a1b0ef1289d704dfd014e5f704182de7e" args="(pFilterOp op0, pFilterOp op1, pFilterOp op2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pWorld::setFilterOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a>&nbsp;</td>
          <td class="paramname"> <em>op0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a>&nbsp;</td>
          <td class="paramname"> <em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a>&nbsp;</td>
          <td class="paramname"> <em>op2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setups filtering operations. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>. </p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op0</em>&nbsp;</td><td>Filter op 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op1</em>&nbsp;</td><td>Filter op 1. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>op2</em>&nbsp;</td><td>Filter op 2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_world.html#aab9935e5e1ece7f1b6cdb6e55003570e" title="Setups filtering&#39;s boolean value. See comments for pGroupsMask.">setFilterBool()</a> <a class="el" href="classp_world.html#abe005c4b63b45090d3f707e5a860b3f7" title="Setups filtering&#39;s K0 value. See comments for pGroupsMask.">setFilterConstant0()</a> <a class="el" href="classp_world.html#ab545ee15bc885a486cb2f293716c1611" title="Setups filtering&#39;s K1 value. See comments for pGroupsMask.">setFilterConstant1()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aab9935e5e1ece7f1b6cdb6e55003570e"></a><!-- doxytag: member="pWorld::setFilterBool" ref="aab9935e5e1ece7f1b6cdb6e55003570e" args="(bool flag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pWorld::setFilterBool </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flag</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setups filtering's boolean value. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>. </p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flag</em>&nbsp;</td><td>Boolean value for filter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_world.html#a1b0ef1289d704dfd014e5f704182de7e" title="Setups filtering operations. See comments for pGroupsMask.">setFilterOps()</a> <a class="el" href="classp_world.html#abe005c4b63b45090d3f707e5a860b3f7" title="Setups filtering&#39;s K0 value. See comments for pGroupsMask.">setFilterConstant0()</a> <a class="el" href="classp_world.html#ab545ee15bc885a486cb2f293716c1611" title="Setups filtering&#39;s K1 value. See comments for pGroupsMask.">setFilterConstant1()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abe005c4b63b45090d3f707e5a860b3f7"></a><!-- doxytag: member="pWorld::setFilterConstant0" ref="abe005c4b63b45090d3f707e5a860b3f7" args="(const pGroupsMask &amp;mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pWorld::setFilterConstant0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classp_groups_mask.html">pGroupsMask</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mask</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setups filtering's K0 value. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>. </p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>The new group mask. See <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_world.html#a1b0ef1289d704dfd014e5f704182de7e" title="Setups filtering operations. See comments for pGroupsMask.">setFilterOps()</a> <a class="el" href="classp_world.html#aab9935e5e1ece7f1b6cdb6e55003570e" title="Setups filtering&#39;s boolean value. See comments for pGroupsMask.">setFilterBool()</a> <a class="el" href="classp_world.html#ab545ee15bc885a486cb2f293716c1611" title="Setups filtering&#39;s K1 value. See comments for pGroupsMask.">setFilterConstant1()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab545ee15bc885a486cb2f293716c1611"></a><!-- doxytag: member="pWorld::setFilterConstant1" ref="ab545ee15bc885a486cb2f293716c1611" args="(const pGroupsMask &amp;mask)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pWorld::setFilterConstant1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classp_groups_mask.html">pGroupsMask</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>mask</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Setups filtering's K1 value. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>. </p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the actors up automatically.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask</em>&nbsp;</td><td>The new group mask. See <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_world.html#a1b0ef1289d704dfd014e5f704182de7e" title="Setups filtering operations. See comments for pGroupsMask.">setFilterOps()</a> <a class="el" href="classp_world.html#aab9935e5e1ece7f1b6cdb6e55003570e" title="Setups filtering&#39;s boolean value. See comments for pGroupsMask.">setFilterBool()</a> <a class="el" href="classp_world.html#abe005c4b63b45090d3f707e5a860b3f7" title="Setups filtering&#39;s K0 value. See comments for pGroupsMask.">setFilterConstant0()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af4dfa5c7a665397dcf73c7e8ead5042e"></a><!-- doxytag: member="pWorld::getFilterOps" ref="af4dfa5c7a665397dcf73c7e8ead5042e" args="(pFilterOp &amp;op0, pFilterOp &amp;op1, pFilterOp &amp;op2) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pWorld::getFilterOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>op0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>op1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga0ee0c41074b14a863a56f5f3f3514899">pFilterOp</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>op2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves filtering operation. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>op0</em>&nbsp;</td><td>First filter operator. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>op1</em>&nbsp;</td><td>Second filter operator. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>op2</em>&nbsp;</td><td>Third filter operator.</td></tr>
  </table>
  </dd>
</dl>
<p>See the user guide page "Contact Filtering" for more details.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the filter operation requested</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_world.html#a1b0ef1289d704dfd014e5f704182de7e" title="Setups filtering operations. See comments for pGroupsMask.">setFilterOps()</a> <a class="el" href="classp_world.html#aab9935e5e1ece7f1b6cdb6e55003570e" title="Setups filtering&#39;s boolean value. See comments for pGroupsMask.">setFilterBool()</a> <a class="el" href="classp_world.html#abe005c4b63b45090d3f707e5a860b3f7" title="Setups filtering&#39;s K0 value. See comments for pGroupsMask.">setFilterConstant0()</a> <a class="el" href="classp_world.html#ab545ee15bc885a486cb2f293716c1611" title="Setups filtering&#39;s K1 value. See comments for pGroupsMask.">setFilterConstant1()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc0b45bf5385e213d9765e4db03aadf1"></a><!-- doxytag: member="pWorld::getFilterBool" ref="abc0b45bf5385e213d9765e4db03aadf1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pWorld::getFilterBool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves filtering's boolean value. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>flag Boolean value for filter.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_world.html#aab9935e5e1ece7f1b6cdb6e55003570e" title="Setups filtering&#39;s boolean value. See comments for pGroupsMask.">setFilterBool()</a> <a class="el" href="classp_world.html#abe005c4b63b45090d3f707e5a860b3f7" title="Setups filtering&#39;s K0 value. See comments for pGroupsMask.">setFilterConstant0()</a> <a class="el" href="classp_world.html#ab545ee15bc885a486cb2f293716c1611" title="Setups filtering&#39;s K1 value. See comments for pGroupsMask.">setFilterConstant1()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a921a6fa26f6596854c65629692f8a109"></a><!-- doxytag: member="pWorld::getFilterConstant0" ref="a921a6fa26f6596854c65629692f8a109" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classp_groups_mask.html">pGroupsMask</a> pWorld::getFilterConstant0 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets filtering constant K0. See comments for <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the filtering constant, as a mask. See <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_world.html#a1b0ef1289d704dfd014e5f704182de7e" title="Setups filtering operations. See comments for pGroupsMask.">setFilterOps()</a> <a class="el" href="classp_world.html#aab9935e5e1ece7f1b6cdb6e55003570e" title="Setups filtering&#39;s boolean value. See comments for pGroupsMask.">setFilterBool()</a> <a class="el" href="classp_world.html#abe005c4b63b45090d3f707e5a860b3f7" title="Setups filtering&#39;s K0 value. See comments for pGroupsMask.">setFilterConstant0()</a> <a class="el" href="classp_world.html#ab545ee15bc885a486cb2f293716c1611" title="Setups filtering&#39;s K1 value. See comments for pGroupsMask.">setFilterConstant1()</a> <a class="el" href="classp_world.html#af0162940a9fc15dd4f152976ceae5012" title="Gets filtering constant K1. See comments for NxGroupsMask.">getFilterConstant1()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af0162940a9fc15dd4f152976ceae5012"></a><!-- doxytag: member="pWorld::getFilterConstant1" ref="af0162940a9fc15dd4f152976ceae5012" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classp_groups_mask.html">pGroupsMask</a> pWorld::getFilterConstant1 </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets filtering constant K1. See comments for NxGroupsMask. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>the filtering constant, as a mask. See <a class="el" href="classp_groups_mask.html" title="128-bit mask used for collision filtering.">pGroupsMask</a>.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_world.html#a1b0ef1289d704dfd014e5f704182de7e" title="Setups filtering operations. See comments for pGroupsMask.">setFilterOps()</a> <a class="el" href="classp_world.html#aab9935e5e1ece7f1b6cdb6e55003570e" title="Setups filtering&#39;s boolean value. See comments for pGroupsMask.">setFilterBool()</a> <a class="el" href="classp_world.html#abe005c4b63b45090d3f707e5a860b3f7" title="Setups filtering&#39;s K0 value. See comments for pGroupsMask.">setFilterConstant0()</a> <a class="el" href="classp_world.html#ab545ee15bc885a486cb2f293716c1611" title="Setups filtering&#39;s K1 value. See comments for pGroupsMask.">setFilterConstant1()</a> <a class="el" href="classp_world.html#a921a6fa26f6596854c65629692f8a109" title="Gets filtering constant K0. See comments for pGroupsMask.">getFilterConstant0()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae66ea4626cb0b1b56a944e9b6f6ba2e6"></a><!-- doxytag: member="pWorld::raycastAnyBounds" ref="ae66ea4626cb0b1b56a944e9b6f6ba2e6" args="(const VxRay &amp;worldRay, pShapesType shapesType, pGroupsMask *groupsMask=NULL, int groups=0xffffffff, float maxDist=pFLOAT_MAX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pWorld::raycastAnyBounds </td>
          <td>(</td>
          <td class="paramtype">const VxRay &amp;&nbsp;</td>
          <td class="paramname"> <em>worldRay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a>&nbsp;</td>
          <td class="paramname"> <em>shapesType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classp_groups_mask.html">pGroupsMask</a> *&nbsp;</td>
          <td class="paramname"> <em>groupsMask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>groups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>maxDist</em> = <code>pFLOAT_MAX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Make certain that the direction vector of NxRay is normalized.</dd>
<dd>
Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediately visible.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldRay</em>&nbsp;</td><td>The ray to cast in the global frame. <b>Range:</b> See NxRay </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapesType</em>&nbsp;</td><td>Choose if to raycast against static, dynamic or both types of shape. See <a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91" title="Used to specify which types(static or dynamic) of shape to test against when used...">pShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groups</em>&nbsp;</td><td>Mask used to filter shape objects. See pRigidBody::setGroup </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxDist</em>&nbsp;</td><td>Max distance to check along the ray for intersecting bounds. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classp_rigid_body.html#afec9beee8ee11d301d3bc6347b0e17a0" title="Sets 128-bit mask used for collision filtering. See comments for pGroupsMask.">pRigidBody::setGroupsMask</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if any axis aligned bounding box enclosing a shape of type shapeType is intersected by the ray</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91" title="Used to specify which types(static or dynamic) of shape to test against when used...">pShapesType</a> VxRay pRigidBody.setGroup() <a class="el" href="classp_world.html#a3a25ea7422fc0c727f600a56f4c951b5" title="Returns true if any shape of type ShapeType is intersected by the ray.">raycastAnyShape()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3a25ea7422fc0c727f600a56f4c951b5"></a><!-- doxytag: member="pWorld::raycastAnyShape" ref="a3a25ea7422fc0c727f600a56f4c951b5" args="(const VxRay &amp;worldRay, pShapesType shapesType, pGroupsMask groupsMask, CKDataArray *cache, int groups=0xffffffff, float maxDist=pFLOAT_MAX)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pWorld::raycastAnyShape </td>
          <td>(</td>
          <td class="paramtype">const VxRay &amp;&nbsp;</td>
          <td class="paramname"> <em>worldRay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a>&nbsp;</td>
          <td class="paramname"> <em>shapesType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classp_groups_mask.html">pGroupsMask</a>&nbsp;</td>
          <td class="paramname"> <em>groupsMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKDataArray *&nbsp;</td>
          <td class="paramname"> <em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>groups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>maxDist</em> = <code>pFLOAT_MAX</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if any shape of type ShapeType is intersected by the ray. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Make certain that the direction vector of NxRay is normalized.</dd>
<dd>
Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediately visible.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldRay</em>&nbsp;</td><td>The ray to cast in the global frame. <b>Range:</b> See VxRay </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapesType</em>&nbsp;</td><td>Choose if to raycast against static, dynamic or both types of shape. See <a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91" title="Used to specify which types(static or dynamic) of shape to test against when used...">pShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groups</em>&nbsp;</td><td>Mask used to filter shape objects. See pRigidBody::setGroup </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxDist</em>&nbsp;</td><td>Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classp_rigid_body.html#afec9beee8ee11d301d3bc6347b0e17a0" title="Sets 128-bit mask used for collision filtering. See comments for pGroupsMask.">pRigidBody::setGroupsMask</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cache</em>&nbsp;</td><td>Possible cache for persistent raycasts, filled out by the SDK.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if any shape of type ShapeType is intersected by the ray.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91" title="Used to specify which types(static or dynamic) of shape to test against when used...">pShapesType</a> VxRay pRigidBody.setGroup() <a class="el" href="classp_world.html#ae66ea4626cb0b1b56a944e9b6f6ba2e6" title="Returns true if any axis aligned bounding box enclosing a shape of type shapeType...">raycastAnyBounds()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9a54cca619ec664ac44d5ed3cb634de6"></a><!-- doxytag: member="pWorld::raycastAllShapes" ref="a9a54cca619ec664ac44d5ed3cb634de6" args="(const VxRay &amp;worldRay, pShapesType shapesType, int groups=0xffffffff, float maxDist=pFLOAT_MAX, pRaycastBit hintFlags=(pRaycastBit) 0xffffffff, const pGroupsMask *groupsMask=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pWorld::raycastAllShapes </td>
          <td>(</td>
          <td class="paramtype">const VxRay &amp;&nbsp;</td>
          <td class="paramname"> <em>worldRay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a>&nbsp;</td>
          <td class="paramname"> <em>shapesType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>groups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>maxDist</em> = <code>pFLOAT_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga97eccd0fec84347c2dbbbe781d83eb78">pRaycastBit</a>&nbsp;</td>
          <td class="paramname"> <em>hintFlags</em> = <code>(<a class="el" href="group___collision.html#ga97eccd0fec84347c2dbbbe781d83eb78">pRaycastBit</a>)&nbsp;0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classp_groups_mask.html">pGroupsMask</a> *&nbsp;</td>
          <td class="paramname"> <em>groupsMask</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls the report's hitCallback() method for all the shapes of type ShapeType intersected by the ray. </p>
<p>hintFlags is a combination of NxRaycastBit flags. Returns the number of shapes hit. The point of impact is provided as a parameter to hitCallback().</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Make certain that the direction vector of NxRay is normalized.</dd>
<dd>
Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<h3>Example</h3>
<div class="fragment"><pre class="fragment"></pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldRay</em>&nbsp;</td><td>The ray to cast in the global frame. <b>Range:</b> See NxRay </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>report</em>&nbsp;</td><td>User callback, to be called when an intersection is encountered. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapesType</em>&nbsp;</td><td>Choose if to raycast against static, dynamic or both types of shape. See NxShapesType. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groups</em>&nbsp;</td><td>Mask used to filter shape objects. See NxShape::setGroup </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxDist</em>&nbsp;</td><td>Max distance to check along the ray for intersecting objects. <b>Range:</b> (0,inf) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hintFlags</em>&nbsp;</td><td>Allows the user to specify which field of NxRaycastHit they are interested in. See NxRaycastBit </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See NxShape::setGroupsMask</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of shapes hit</dd></dl>
<p><b>Platform:</b> </p>
<ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_world.html#a3a25ea7422fc0c727f600a56f4c951b5" title="Returns true if any shape of type ShapeType is intersected by the ray.">raycastAnyShape()</a> raycastAllBounds() NxRay NxUserRaycastReport NxShapesType NxShape.setGroup() NxRaycastHit </dd></dl>

</div>
</div>
<a class="anchor" id="afc72fdaa6759f68c5f322de84074bbf9"></a><!-- doxytag: member="pWorld::overlapSphereShapes" ref="afc72fdaa6759f68c5f322de84074bbf9" args="(const VxSphere &amp;worldSphere, CK3dEntity *shapeReference, pShapesType shapeType, CKGroup *shapes, int activeGroups=0xffffffff, const pGroupsMask *groupsMask=NULL, bool accurateCollision=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pWorld::overlapSphereShapes </td>
          <td>(</td>
          <td class="paramtype">const VxSphere &amp;&nbsp;</td>
          <td class="paramname"> <em>worldSphere</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CK3dEntity *&nbsp;</td>
          <td class="paramname"> <em>shapeReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a>&nbsp;</td>
          <td class="paramname"> <em>shapeType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKGroup *&nbsp;</td>
          <td class="paramname"> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classp_groups_mask.html">pGroupsMask</a> *&nbsp;</td>
          <td class="paramname"> <em>groupsMask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>accurateCollision</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the set of shapes overlapped by the world-space sphere. </p>
<p>You can test against static and/or dynamic objects by adjusting 'shapeType'. Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'.</p>
<p>The function returns the total number of collided shapes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldSphere</em>&nbsp;</td><td>Sphere description in world space. <b>Range:</b> See VxSphere </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See <a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91" title="Used to specify which types(static or dynamic) of shape to test against when used...">pShapesType</a>. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Buffer to store intersecting shapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See pRigidBody::setGroup </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classp_rigid_body.html#afec9beee8ee11d301d3bc6347b0e17a0" title="Sets 128-bit mask used for collision filtering. See comments for pGroupsMask.">pRigidBody::setGroupsMask</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>accurateCollision</em>&nbsp;</td><td>True to test the sphere against the actual shapes, false to test against the AABBs only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the total number of collided shapes.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91" title="Used to specify which types(static or dynamic) of shape to test against when used...">pShapesType</a> <a class="el" href="classp_world.html#a378c2149175107725863f669b5473c1c" title="Returns the set of shapes overlapped by the world-space AABB.">overlapAABBShapes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a378c2149175107725863f669b5473c1c"></a><!-- doxytag: member="pWorld::overlapAABBShapes" ref="a378c2149175107725863f669b5473c1c" args="(const VxBbox &amp;worldBounds, CK3dEntity *shapeReference, pShapesType shapeType, CKGroup *shapes, int activeGroups=0xffffffff, const pGroupsMask *groupsMask=NULL, bool accurateCollision=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pWorld::overlapAABBShapes </td>
          <td>(</td>
          <td class="paramtype">const VxBbox &amp;&nbsp;</td>
          <td class="paramname"> <em>worldBounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CK3dEntity *&nbsp;</td>
          <td class="paramname"> <em>shapeReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a>&nbsp;</td>
          <td class="paramname"> <em>shapeType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKGroup *&nbsp;</td>
          <td class="paramname"> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classp_groups_mask.html">pGroupsMask</a> *&nbsp;</td>
          <td class="paramname"> <em>groupsMask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>accurateCollision</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the set of shapes overlapped by the world-space AABB. </p>
<p>You can test against static and/or dynamic objects by adjusting 'shapeType'. Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'.</p>
<p>The function returns the total number of collided shapes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldBounds</em>&nbsp;</td><td>Axis Aligned Bounding Box in world space. <b>Range:</b> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See pShapesType. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Buffer to store intersecting shapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See pRigidBody::setGroup </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See <a class="el" href="classp_rigid_body.html#afec9beee8ee11d301d3bc6347b0e17a0" title="Sets 128-bit mask used for collision filtering. See comments for pGroupsMask.">pRigidBody::setGroupsMask</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>accurateCollision</em>&nbsp;</td><td>True to test the AABB against the actual shapes, false to test against the AABBs only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the total number of collided shapes.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>pxShapesType <a class="el" href="classp_world.html#a378c2149175107725863f669b5473c1c" title="Returns the set of shapes overlapped by the world-space AABB.">overlapAABBShapes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a73939bc30803a597084c7139ebd1f678"></a><!-- doxytag: member="pWorld::overlapOBBShapes" ref="a73939bc30803a597084c7139ebd1f678" args="(const VxBbox &amp;worldBox, CK3dEntity *shapeReference, pShapesType shapeType, CKGroup *shapes, int activeGroups=0xffffffff, const pGroupsMask *groupsMask=NULL, bool accurateCollision=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pWorld::overlapOBBShapes </td>
          <td>(</td>
          <td class="paramtype">const VxBbox &amp;&nbsp;</td>
          <td class="paramname"> <em>worldBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CK3dEntity *&nbsp;</td>
          <td class="paramname"> <em>shapeReference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91">pShapesType</a>&nbsp;</td>
          <td class="paramname"> <em>shapeType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CKGroup *&nbsp;</td>
          <td class="paramname"> <em>shapes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>activeGroups</em> = <code>0xffffffff</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classp_groups_mask.html">pGroupsMask</a> *&nbsp;</td>
          <td class="paramname"> <em>groupsMask</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>accurateCollision</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the set of shapes overlapped by the world-space OBB. </p>
<p>You can test against static and/or dynamic objects by adjusting 'shapeType'.</p>
<p>The function returns the total number of collided shapes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldBox</em>&nbsp;</td><td>Oriented Bounding Box in world space. <b>Range:</b> See NxBox </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See NxShape::setGroup </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See NxShape::setGroupsMask </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>accurateCollision</em>&nbsp;</td><td>True to test the OBB against the actual shapes, false to test against the AABBs only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the total number of collided shapes.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91" title="Used to specify which types(static or dynamic) of shape to test against when used...">pShapesType</a> <a class="el" href="classp_world.html#a73939bc30803a597084c7139ebd1f678" title="Returns the set of shapes overlapped by the world-space OBB.">overlapOBBShapes</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab0ca898e6b3c4be436a3fa13818911c8"></a><!-- doxytag: member="pWorld::step" ref="ab0ca898e6b3c4be436a3fa13818911c8" args="(float stepsize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pWorld::step </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>stepsize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the set of shapes overlapped by the world-space capsule. </p>
<p>You can test against static and/or dynamic objects by adjusting 'shapeType'. Shapes are written to the static array 'shapes', which should be big enough to hold 'nbShapes'. An alternative is to use the NxUserEntityReport callback mechanism.</p>
<p>The function returns the total number of collided shapes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Because the SDK double buffers shape state, a shape will not be updated until a simulation step is taken. For example the result of setting the global pose is not immediatly visible.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>worldCapsule</em>&nbsp;</td><td>capsule in world space. <b>Range:</b> See NxCapsule </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shapeType</em>&nbsp;</td><td>Choose if to intersect with static, dynamic or both types of shape. See NxShapesType. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>shapes</em>&nbsp;</td><td>Buffer to store intersecting shapes. Should be at least sizeof(NxShape *) * nbShapes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>activeGroups</em>&nbsp;</td><td>Mask used to filter shape objects. See NxShape::setGroup </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>groupsMask</em>&nbsp;</td><td>Alternative mask used to filter shapes. See NxShape::setGroupsMask </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>accurateCollision</em>&nbsp;</td><td>True to test the capsule against the actual shapes, false to test against the AABBs only.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the total number of collided shapes.</dd></dl>
<p><b>Platform:</b> </p>
<ul>
<li>PC SW: Yes </li>
<li>PPU : Yes </li>
<li>PS3 : Yes </li>
<li>XB360: Yes</li>
</ul>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group___collision.html#ga595b91d1d6b10332fe942b671f25bc91" title="Used to specify which types(static or dynamic) of shape to test against when used...">pShapesType</a> overlapCapsuleShapes </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Feb 3 18:57:24 2010 for vtPhysX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
