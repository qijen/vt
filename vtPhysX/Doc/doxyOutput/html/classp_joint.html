<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>vtPhysX: pJoint Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="online.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>pJoint Class Reference<br/>
<small>
[<a class="el" href="group___joints.html">Joints</a>]</small>
</h1><!-- doxytag: class="pJoint" -->
<p>Abstract base class for the different types of joints.  
<a href="#_details">More...</a></p>

<p>Inherited by <a class="el" href="classp_joint_ball.html">pJointBall</a>, <a class="el" href="classp_joint_cylindrical.html">pJointCylindrical</a>, <a class="el" href="classp_joint_d6.html">pJointD6</a>, <a class="el" href="classp_joint_distance.html">pJointDistance</a>, pJointFixed, <a class="el" href="classp_joint_point_in_plane.html">pJointPointInPlane</a>, <a class="el" href="classp_joint_point_on_line.html">pJointPointOnLine</a>, <a class="el" href="classp_joint_prismatic.html">pJointPrismatic</a>, <a class="el" href="classp_joint_pulley.html">pJointPulley</a>, and <a class="el" href="classp_joint_revolute.html">pJointRevolute</a>.</p>

<p><a href="classp_joint-members.html">List of all members.</a></p>
<h2>Public Member Functions</h2>
<ul>
<li><a class="el" href="group___joints.html#gadcea5be96146723d822b7db05024d881">JType</a> <a class="el" href="classp_joint.html#a130436a85858b469f5d4b2ce76a5442c">getType</a> () const 
<dl class="el"><dd class="mdescRight">Retrieve the type of this joint.  <a href="#a130436a85858b469f5d4b2ce76a5442c"></a><br/></dl><li>void <a class="el" href="classp_joint.html#ae62c1e3223625c6d96d681ac8e10d00b">setBreakForces</a> (float maxForce, float maxTorque)
<dl class="el"><dd class="mdescRight">Sets the maximum force magnitude that the joint is able to withstand without breaking.  <a href="#ae62c1e3223625c6d96d681ac8e10d00b"></a><br/></dl><li>void <a class="el" href="classp_joint.html#aad70b3abdc56cb7f4ab0d272d91424c4">getBreakForces</a> (float &amp;maxForce, float &amp;maxTorque)
<dl class="el"><dd class="mdescRight">Retrieves the max forces of a breakable joint. See setBreakable().  <a href="#aad70b3abdc56cb7f4ab0d272d91424c4"></a><br/></dl><li>int <a class="el" href="classp_joint.html#adfe2bdeb9b2ad57ff8cc7be76f0d046a">addLimitPlane</a> (const VxVector normal, VxVector pointInPlane, float restitution=0.0f)
<dl class="el"><dd class="mdescRight">Adds a limit plane.  <a href="#adfe2bdeb9b2ad57ff8cc7be76f0d046a"></a><br/></dl><li>void <a class="el" href="classp_joint.html#a85de66102a9335f1131f791ef0ac4c74">purgeLimitPlanes</a> ()
<dl class="el"><dd class="mdescRight">deletes all limit planes added to the joint.  <a href="#a85de66102a9335f1131f791ef0ac4c74"></a><br/></dl><li>void <a class="el" href="classp_joint.html#a7344f8264507c333e0257a022cc052d9">resetLimitPlaneIterator</a> ()
<dl class="el"><dd class="mdescRight">Restarts the limit plane iteration.  <a href="#a7344f8264507c333e0257a022cc052d9"></a><br/></dl><li>int <a class="el" href="classp_joint.html#ad5410741f23ee18a0dca715af9a96d4b">hasMoreLimitPlanes</a> ()
<dl class="el"><dd class="mdescRight">Returns true until the iterator reaches the end of the set of limit planes.  <a href="#ad5410741f23ee18a0dca715af9a96d4b"></a><br/></dl><li>int <a class="el" href="classp_joint.html#ac75915643b7c277853069778b2f96cab">getNextLimitPlane</a> (VxVector &amp;planeNormal, float &amp;planeD, float *restitution=NULL)
<dl class="el"><dd class="mdescRight">Returns the next element pointed to by the limit plane iterator, and increments the iterator.  <a href="#ac75915643b7c277853069778b2f96cab"></a><br/></dl><li>void <a class="el" href="classp_joint.html#af28b8cc5bfd363d0b1d0188be6f13f5a">setLimitPoint</a> (VxVector point, bool pointIsOnActor2=true)
<dl class="el"><dd class="mdescRight">Sets the limit point.  <a href="#af28b8cc5bfd363d0b1d0188be6f13f5a"></a><br/></dl><li>bool <a class="el" href="classp_joint.html#ab7ce99618d465ea134d0db2afed59916">getLimitPoint</a> (VxVector &amp;worldLimitPoint)
<dl class="el"><dd class="mdescRight">Retrieves the global space limit point.  <a href="#ab7ce99618d465ea134d0db2afed59916"></a><br/></dl></ul>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Abstract base class for the different types of joints. </p>
<p>All joints are used to connect two dynamic bodies, or an body and the environment.</p>
<p>A NULL body represents the environment. Whenever the below comments mention two bodies, one of them may always be the environment (NULL). </p>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a130436a85858b469f5d4b2ce76a5442c"></a><!-- doxytag: member="pJoint::getType" ref="a130436a85858b469f5d4b2ce76a5442c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___joints.html#gadcea5be96146723d822b7db05024d881">JType</a> pJoint::getType </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve the type of this joint. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The type of joint.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>NxJointType </dd></dl>

</div>
</div>
<a class="anchor" id="ae62c1e3223625c6d96d681ac8e10d00b"></a><!-- doxytag: member="pJoint::setBreakForces" ref="ae62c1e3223625c6d96d681ac8e10d00b" args="(float maxForce, float maxTorque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pJoint::setBreakForces </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>maxForce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>maxTorque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the maximum force magnitude that the joint is able to withstand without breaking. </p>
<p>There are two values, one for linear forces, and one for angular forces. Both values are used directly as a value for the maximum impulse tolerated by the joint constraints.</p>
<p>Both force values are MaxFloat by default. This setting makes the joint unbreakable. The values should always be nonnegative.</p>
<p>The distinction between maxForce and maxTorque is dependent on how the joint is implemented internally, which may not be obvious. For example what appears to be an angular degree of freedom may be constrained indirectly by a linear constraint.</p>
<p>So in most practical applications the user should set both maxTorque and maxForce to low values.</p>
<p><b>Sleeping:</b> This call wakes the body(s) if they are sleeping.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxForce</em>&nbsp;</td><td>Maximum force the joint can withstand without breaking. <b>Range:</b> (0,inf] </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxTorque</em>&nbsp;</td><td>Maximum torque the joint can withstand without breaking. <b>Range:</b> (0,inf] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad70b3abdc56cb7f4ab0d272d91424c4"></a><!-- doxytag: member="pJoint::getBreakForces" ref="aad70b3abdc56cb7f4ab0d272d91424c4" args="(float &amp;maxForce, float &amp;maxTorque)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pJoint::getBreakForces </td>
          <td>(</td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>maxForce</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>maxTorque</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the max forces of a breakable joint. See setBreakable(). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>maxForce</em>&nbsp;</td><td>Retrieves the maximum force the joint can withstand without breaking. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>maxTorque</em>&nbsp;</td><td>Retrieves the maximum torque the joint can withstand without breaking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adfe2bdeb9b2ad57ff8cc7be76f0d046a"></a><!-- doxytag: member="pJoint::addLimitPlane" ref="adfe2bdeb9b2ad57ff8cc7be76f0d046a" args="(const VxVector normal, VxVector pointInPlane, float restitution=0.0f)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pJoint::addLimitPlane </td>
          <td>(</td>
          <td class="paramtype">const VxVector&nbsp;</td>
          <td class="paramname"> <em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VxVector&nbsp;</td>
          <td class="paramname"> <em>pointInPlane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>restitution</em> = <code>0.0f</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a limit plane. </p>
<p>Both of the parameters are given in global coordinates. see <a class="el" href="classp_joint.html#af28b8cc5bfd363d0b1d0188be6f13f5a" title="Sets the limit point.">setLimitPoint()</a> for the meaning of limit planes.</p>
<p>The plane is affixed to the body that does not have the limit point.</p>
<p>The normal of the plane points toward the positive side of the plane, and thus toward the limit point. If the normal points away from the limit point at the time of this call, the method returns false and the limit plane is ignored.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function always returns true and adds the limit plane unlike earlier versions. This behavior was changed to allow the joint to be serialized easily.</dd></dl>
<p><b>Sleeping:</b> This call wakes the body(s) if they are sleeping.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>normal</em>&nbsp;</td><td>Normal for the limit plane in global coordinates. <b>Range:</b> direction vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pointInPlane</em>&nbsp;</td><td>Point in the limit plane in global coordinates. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>restitution</em>&nbsp;</td><td>Restitution of the limit plane. <b>Range:</b> [0.0, 1.0] <b>Default:</b> 0.0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Always true.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_joint.html#af28b8cc5bfd363d0b1d0188be6f13f5a" title="Sets the limit point.">setLimitPoint()</a> <a class="el" href="classp_joint.html#a85de66102a9335f1131f791ef0ac4c74" title="deletes all limit planes added to the joint.">purgeLimitPlanes()</a> <a class="el" href="classp_joint.html#ac75915643b7c277853069778b2f96cab" title="Returns the next element pointed to by the limit plane iterator, and increments the...">getNextLimitPlane()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a85de66102a9335f1131f791ef0ac4c74"></a><!-- doxytag: member="pJoint::purgeLimitPlanes" ref="a85de66102a9335f1131f791ef0ac4c74" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pJoint::purgeLimitPlanes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>deletes all limit planes added to the joint. </p>
<p>Invalidates limit plane iterator.</p>
<p><b>Sleeping:</b> Does <b>NOT</b> wake the associated body up automatically.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_joint.html#adfe2bdeb9b2ad57ff8cc7be76f0d046a" title="Adds a limit plane.">addLimitPlane()</a> <a class="el" href="classp_joint.html#ac75915643b7c277853069778b2f96cab" title="Returns the next element pointed to by the limit plane iterator, and increments the...">getNextLimitPlane()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7344f8264507c333e0257a022cc052d9"></a><!-- doxytag: member="pJoint::resetLimitPlaneIterator" ref="a7344f8264507c333e0257a022cc052d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pJoint::resetLimitPlaneIterator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Restarts the limit plane iteration. </p>
<p>Call before starting to iterate. This method may be used together with the below two methods to enumerate the limit planes. This iterator becomes invalid when planes are added or removed, or the plane iterator mechanism is invoked on another joint.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_joint.html#ad5410741f23ee18a0dca715af9a96d4b" title="Returns true until the iterator reaches the end of the set of limit planes.">hasMoreLimitPlanes()</a> <a class="el" href="classp_joint.html#ac75915643b7c277853069778b2f96cab" title="Returns the next element pointed to by the limit plane iterator, and increments the...">getNextLimitPlane()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad5410741f23ee18a0dca715af9a96d4b"></a><!-- doxytag: member="pJoint::hasMoreLimitPlanes" ref="ad5410741f23ee18a0dca715af9a96d4b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pJoint::hasMoreLimitPlanes </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true until the iterator reaches the end of the set of limit planes. </p>
<p>Adding or removing elements does not reset the iterator.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the iterator has not reached the end of the sequence of limit planes.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_joint.html#a7344f8264507c333e0257a022cc052d9" title="Restarts the limit plane iteration.">resetLimitPlaneIterator()</a> <a class="el" href="classp_joint.html#ac75915643b7c277853069778b2f96cab" title="Returns the next element pointed to by the limit plane iterator, and increments the...">getNextLimitPlane()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac75915643b7c277853069778b2f96cab"></a><!-- doxytag: member="pJoint::getNextLimitPlane" ref="ac75915643b7c277853069778b2f96cab" args="(VxVector &amp;planeNormal, float &amp;planeD, float *restitution=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pJoint::getNextLimitPlane </td>
          <td>(</td>
          <td class="paramtype">VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>planeNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>planeD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>restitution</em> = <code>NULL</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the next element pointed to by the limit plane iterator, and increments the iterator. </p>
<p>Places the global frame plane equation (consisting of normal and d, the 4th element) coefficients in the argument references. The plane equation is of the form:</p>
<p>dot(n,p) + d == 0 (n = normal, p = a point on the plane)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>planeNormal</em>&nbsp;</td><td>Used to store the plane normal. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>planeD</em>&nbsp;</td><td>Used to store the plane 'D'. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>restitution</em>&nbsp;</td><td>Optional, used to store restitution of the limit plane. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns true if the limit plane is satisfied.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_joint.html#a7344f8264507c333e0257a022cc052d9" title="Restarts the limit plane iteration.">resetLimitPlaneIterator()</a> <a class="el" href="classp_joint.html#ad5410741f23ee18a0dca715af9a96d4b" title="Returns true until the iterator reaches the end of the set of limit planes.">hasMoreLimitPlanes()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af28b8cc5bfd363d0b1d0188be6f13f5a"></a><!-- doxytag: member="pJoint::setLimitPoint" ref="af28b8cc5bfd363d0b1d0188be6f13f5a" args="(VxVector point, bool pointIsOnActor2=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pJoint::setLimitPoint </td>
          <td>(</td>
          <td class="paramtype">VxVector&nbsp;</td>
          <td class="paramname"> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pointIsOnActor2</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the limit point. </p>
<p>The point is specified in the global coordinate frame.</p>
<p>All types of joints may be limited with the same system: You may elect a point attached to one of the two bodies to act as the limit point. You may also specify several planes attached to the other body.</p>
<p>The points and planes move together with the body they are attached to.</p>
<p>The simulation then makes certain that the pair of bodies only move relative to each other so that the limit point stays on the positive side of all limit planes.</p>
<p>the default limit point is (0,0,0) in the local frame of actor2. Calling this deletes all existing limit planes.</p>
<p><b>Sleeping:</b> This call wakes the body(s) if they are sleeping.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>point</em>&nbsp;</td><td>The limit reference point defined in the global frame. <b>Range:</b> position vector </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pointIsOnActor2</em>&nbsp;</td><td>if true the point is attached to the second body. Otherwise it is attached to the first.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_joint.html#ab7ce99618d465ea134d0db2afed59916" title="Retrieves the global space limit point.">getLimitPoint()</a> <a class="el" href="classp_joint.html#adfe2bdeb9b2ad57ff8cc7be76f0d046a" title="Adds a limit plane.">addLimitPlane()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab7ce99618d465ea134d0db2afed59916"></a><!-- doxytag: member="pJoint::getLimitPoint" ref="ab7ce99618d465ea134d0db2afed59916" args="(VxVector &amp;worldLimitPoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pJoint::getLimitPoint </td>
          <td>(</td>
          <td class="paramtype">VxVector &amp;&nbsp;</td>
          <td class="paramname"> <em>worldLimitPoint</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the global space limit point. </p>
<p>Returns true if the point is fixed on actor2.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>worldLimitPoint</em>&nbsp;</td><td>Used to store the global frame limit point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the point is fixed to body 2 otherwise the point is fixed to body 1.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classp_joint.html#af28b8cc5bfd363d0b1d0188be6f13f5a" title="Sets the limit point.">setLimitPoint()</a> <a class="el" href="classp_joint.html#adfe2bdeb9b2ad57ff8cc7be76f0d046a" title="Adds a limit plane.">addLimitPlane()</a> </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Wed Feb 3 18:57:24 2010 for vtPhysX by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
